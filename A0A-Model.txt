Write A Python program for Prim's Minimum Spanning Tree (MST) algorithm.
import sys 
class Graph():
	def __init__(self, vertices):
		self.V = vertices
		self.graph = [[0 for column in range(vertices)]
					for row in range(vertices)]
	def printMST(self, parent):
		print ("Edge   Weight")
		for i in range(1, self.V):
			print (parent[i], "-", i, "  ",self.graph[i][parent[i]])
	def minKey(self, key, mstSet):
		min = sys.maxsize
		for v in range(self.V):
			if key[v] < min and mstSet[v] == False:
				min = key[v]
				min_index = v
		return min_index
	def primMST(self):
		key = [sys.maxsize] * self.V
		parent = [None] * self.V 
		key[0] = 0
		mstSet = [False] * self.V
		parent[0] = -1 
		for cout in range(self.V):
			u = self.minKey(key, mstSet)
			mstSet[u] = True
			for v in range(self.V):
				if self.graph[u][v] > 0 and mstSet[v] == False and key[v] > self.graph[u][v]:
						key[v] = self.graph[u][v]
						parent[v] = u
		self.printMST(parent)
g = Graph(5)
g.graph = [ [0, 2, 0, 6, 0],
			[2, 0, 3, 8, 5],
			[0, 3, 0, 0, 7],
			[6, 8, 0, 0, 9],
			[0, 5, 7, 9, 0]]

g.primMST();
##
Write a  Python program for Kruskal's algorithm to find Minimum Spanning Tree of a given connected, undirected and weighted graph
from collections import defaultdict
class Graph:
	def __init__(self, vertices):
		self.V = vertices 
		self.graph = [] 
	def addEdge(self, u, v, w):
		self.graph.append([u, v, w])
	def find(self, parent, i):
		if parent[i] == i:
			return i
		return self.find(parent, parent[i])
	def union(self, parent, rank, x, y):
		xroot = self.find(parent, x)
		yroot = self.find(parent, y)
		if rank[xroot] < rank[yroot]:
			parent[xroot] = yroot
		elif rank[xroot] > rank[yroot]:
			parent[yroot] = xroot
		else:
			parent[yroot] = xroot
			rank[xroot] += 1
	def KruskalMST(self):
		result = [] 
		i = 0
		e = 0
		self.graph = sorted(self.graph,
							key=lambda item: item[2])
		parent = []
		rank = []
		for node in range(self.V):
			parent.append(node)
			rank.append(0)
		while e < self.V - 1:
			u, v, w = self.graph[i]
			i = i + 1
			x = self.find(parent, u)
			y = self.find(parent, v)
			if x != y:
				e = e + 1
				result.append([u, v, w])
				self.union(parent, rank, x, y)
		minimumCost = 0
		print ("Edges in the constructed MST")
		for u, v, weight in result:
			minimumCost += weight
			print("%d -- %d == %d" % (u, v, weight))
		print("Minimum Spanning Tree" , minimumCost)
g = Graph(4)
g.addEdge(0, 1, 10)
g.addEdge(0, 2, 6)
g.addEdge(0, 3, 5)
g.addEdge(1, 3, 15)
g.addEdge(2, 3, 4)
g.KruskalMST()
##
Write a Python program for Dijkstra's single source shortest path algorithm. 
import sys
class Graph():
	def __init__(self, vertices):
		self.V = vertices
		self.graph = [[0 for column in range(vertices)]
					for row in range(vertices)]
	def printSolution(self, dist):
		print("Vertex   Distance from Source")
		for node in range(self.V):
			print(node, "           ", dist[node])
	def minDistance(self, dist, sptSet):
		min = sys.maxsize
		for u in range(self.V):
			if dist[u] < min and sptSet[u] == False:
				min = dist[u]
				min_index = u
		return min_index
	def dijkstra(self, src):
		dist = [sys.maxsize] * self.V
		dist[src] = 0
		sptSet = [False] * self.V
		for cout in range(self.V):
			x = self.minDistance(dist, sptSet)
			sptSet[x] = True
			for y in range(self.V):
				if self.graph[x][y] > 0 and sptSet[y] == False and 				dist[y] > dist[x] + self.graph[x][y]:
						dist[y] = dist[x] + self.graph[x][y]
		self.printSolution(dist)
g = Graph(9)
g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],
		[4, 0, 8, 0, 0, 0, 0, 11, 0],
		[0, 8, 0, 7, 0, 4, 0, 0, 2],
		[0, 0, 7, 0, 6, 14, 0, 0, 0],
		[0, 0, 0, 6, 0, 5, 0, 0, 0],
		[0, 0, 4, 14, 5, 0, 2, 0, 0],
		[0, 0, 0, 0, 0, 2, 0, 1, 6],
		[8, 11, 0, 0, 0, 0, 1, 0, 7],
		[0, 0, 2, 0, 0, 0, 6, 7, 0]
		];
g.dijkstra(0);
##
Implement the dijkstra() function only.
import sys
class Graph():
	def __init__(self, vertices):
		self.V = vertices
		self.graph = [[0 for column in range(vertices)]
					for row in range(vertices)]
	def printSolution(self, dist):
		print("Vertex   Distance from Source")
		for node in range(self.V):
			print(node, "           ", dist[node])
	def minDistance(self, dist, sptSet):
		min = sys.maxsize
		for u in range(self.V):
			if dist[u] < min and sptSet[u] == False:
				min = dist[u]
				min_index = u
		return min_index
	def dijkstra(self, src):
		dist = [sys.maxsize] * self.V
		dist[src] = 0
		sptSet = [False] * self.V
		for cout in range(self.V):
			x = self.minDistance(dist, sptSet)
			sptSet[x] = True
			for y in range(self.V):
				if self.graph[x][y] > 0 and sptSet[y] == False and 				dist[y] > dist[x] + self.graph[x][y]:
						dist[y] = dist[x] + self.graph[x][y]
		self.printSolution(dist)
g = Graph(9)
g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],
		[4, 0, 8, 0, 0, 0, 0, 11, 0],
		[0, 8, 0, 7, 0, 4, 0, 0, 2],
		[0, 0, 7, 0, 9, 14, 0, 0, 0],
		[0, 0, 0, 9, 0, 10, 0, 0, 0],
		[0, 0, 4, 14, 10, 0, 2, 0, 0],
		[0, 0, 0, 0, 0, 2, 0, 1, 6],
		[8, 11, 0, 0, 0, 0, 1, 0, 7],
		[0, 0, 2, 0, 0, 0, 6, 7, 0]
		];

g.dijkstra(0);
##
Travelling Salesman Problem (TSP) : Given a set of cities and distances between every pair of cities, the problem is to find the shortest possible route that visits every city exactly once and returns to the starting point. 
from sys import maxsize
from itertools import permutations
V = 4
def travellingSalesmanProblem(graph, s):
	vertex = []
	for i in range(V):
		if i != s:
			vertex.append(i)
	min_path = maxsize
	next_permutation=permutations(vertex)
	for i in next_permutation:
		current_pathweight = 0
		k = s
		for j in i:
			current_pathweight += graph[k][j]
			k = j
		current_pathweight += graph[k][s]
		min_path = min(min_path, current_pathweight)		
	return min_path
if __name__ == "__main__":
	graph = [[0, 10, 15, 20], [10, 0, 35, 25],
			[15, 35, 0, 30], [20, 25, 30, 0]]
	s = int(input())
	print(travellingSalesmanProblem(graph, s))
##
Given an Undirected simple graph, We need to find how many triangles it can have. For example below graph have 2 triangles in it.
def multiply(A, B, C):
	global V
	for i in range(V):
		for j in range(V):
			C[i][j] = 0
			for k in range(V):
				C[i][j] += A[i][k] * B[k][j]
def getTrace(graph):
	global V
	trace = 0
	for i in range(V):
		trace += graph[i][i]
	return trace
def triangleInGraph(graph):
	global V
	aux2 = [[None] * V for i in range(V)]
	aux3 = [[None] * V for i in range(V)]
	for i in range(V):
		for j in range(V):
			aux2[i][j] = aux3[i][j] = 0
	multiply(graph, graph, aux2)
	multiply(graph, aux2, aux3)
	trace = getTrace(aux3)
	return trace // 6
V = int(input())
graph = [[0, 1, 1, 0],
		[1, 0, 1, 1],
		[1, 1, 0, 1],
		[0, 1, 1, 0]]
print("Total number of Triangle in Graph :",
					triangleInGraph(graph))
##
Write a Python Program to print factorial of a number recursively.
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)
num = int(input())
result = factorial(num)
print(f"Factorial of number {num} = {result}")
##
Write a Python Program to calculate the GCD of the given two numbers using Recursive function
def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)
num1 = int(input())
num2 = int(input())
result = gcd(num1, num2)
print(result)
##
Write a short recursive python function that finds the maximum value in a sequence without using any loops
def find_max(n, current_max=float('-inf')):
    if n == 0:
        return current_max
    value = int(input())
    current_max = max(current_max, value)
    return find_max(n - 1, current_max)

n = int(input())
print(find_max(n))
##
Write a Python program to calculate the harmonic sum of n-1.
Note: The harmonic sum is the sum of reciprocals of the positive integers.
def harmonic_sum(n):
  if n < 2:
    return 1
  else:
    return 1 / n + (harmonic_sum(n - 1))
n=int(input())
print(harmonic_sum(n))
##
Write a Python program to print the following pattern based on the given input.
def print_pattern(n):
    print()  
    for i in range(1, n):
        print('*' * i)
input_value = int(input())
print_pattern(input_value)
##
Write a Python Program to print the fibonacci series upto n_terms using Recursion.
def fibo(n):
    if n<=1:
        return n
    else:
        return fibo(n-1)+fibo(n-2)
n=int(input())
print("Fibonacci series:")
for i in range(n):
    print(fibo(i))
##
Write a python Program Using Recursive Function which  calculates the value of a number multiplied by itself a certain number of times.
def power_recursive(base, exponent):
    if exponent == 0:
        return 1
    return base * power_recursive(base, exponent - 1)
base = int(input())
exponent = int(input())
result = power_recursive(base, exponent)
print(f"{base} to the power of {exponent} is {result}")
##
Write a python program to calculate the length of the given string using recursion
def length(str):
    if str:
        return 1+length(str[1:])
    else:
        return 0
str=input()
res=length(str)
print("length of",str,"is",res)
##
Input:6
def print_pattern(n):
    for i in range(1, n):
        print(f"{i} " * i)
n = int(input())
print_pattern(n)
##
Write a Program to Create a recursive function to reverse a string.
def reverse(string):
    if string:
        return reverse(string[1:]) + string[0]
    return ""
reverseme = input()
print(reverse(reverseme))
##
Write a short recursive Python function that finds the minimum and maximum values in a sequence without using any loops.
def maximum_in_list(nums):
    if len(nums) == 1:
        return nums[0]
    else:
        return max(nums[0],maximum_in_list(nums[1:]))
list1=[]
n=int(input())
for i in range(n):
    list1.append(int(input()))
print(maximum_in_list(list1))
##
harmonic_sum(n)
def harmonic_sum(n):
  if n < 2:
    return 1
  else:
    return 1 / n + (harmonic_sum(n - 1))
n=int(input())
print(harmonic_sum(n))
##
Write a recursive python function to perform merge sort on the unsorted list of values.
def mergesort(arr):
    global size
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]
        mergesort(L)
        mergesort(R)
        i = j = k = 0
        while(i < len(L) and j < len(R)):
            if L[i] <= R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        while (i < len(L)):
            arr[k] = L[i]
            i += 1
            k += 1
        while (j < len(R)):
            arr[k] = R[j]
            j += 1
            k += 1
    if size == len(arr):
        print(arr)
size = int(input())
li = [int(input()) for i in range(size)]
##
Write a python program to sort the first half of the list using merge sort
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    L = [0] * (n1)
    R = [0] * (n2)
    for i in range(0, n1):
        L[i] = arr[l + i]
    for j in range(0, n2):
        R[j] = arr[m + 1 + j]
    i = 0     
    j = 0     
    k = l     
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1
def mergeSort(arr, l, r):
    if l < r:
        m = l+(r-l)//2
        mergeSort(arr, m+1, r)
        merge(arr, l, m, r)
arr =[]               
n =int(input())
for i in range(n):
    arr.append(int(input()))
print("Given array is")
for i in range(n):
    print("%d" % arr[i],end=" ")
mergeSort(arr, 0, n-1)
print("\n\nSorted array is")
for i in range(n):
    print("%d" % arr[i],end=" ")
##
Write a python program to implement merge sort without using recursive function on the given list of values.
def merge(left, right):
    result = []
    x, y = 0, 0
    for k in range(0, len(left) + len(right)):
        if x == len(left): 
            result.append(right[y]) 
            y += 1
        elif y == len(right): 
            result.append(left[x])
            x += 1
        elif right[y] < left[x]:
            result.append(right[y])
            y += 1
        else:
            result.append(left[x])
            x += 1
    return result
def mergesort(ar_list):
    length = len(ar_list)
    size = 1
    while size < length:
        size+=size 
        for pos in range(0, length, size):
         start = pos
         mid = pos + int(size / 2)
         end = pos + size
         left = ar_list[ start : mid ]
         right = ar_list[ mid : end ]
         print("left: ",left)
         print("Right: ",right)
         ar_list[start:end] = merge(left, right)
    return ar_list 
ar_list = []
n=int(input())
for i in range(n):
    ar_list.append(int(input()))
print(mergesort(ar_list))
##
Write a Python Program to find minimum number of swaps required to sort an float array given by the user.
def minSwaps(arr):
    n = len(arr)
    arrpos = [*enumerate(arr)]
    arrpos.sort(key = lambda x:x[1])
    vis = {k : False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arrpos[i][0] == i:
            continue
        cyclesize = 0
        j = i
        while not vis[j] :
            vis[j] = True
            j = arrpos[j][0]
            cyclesize += 1
        if cyclesize > 0:
            ans += cyclesize - 1
    print(ans)
size = int(input())
arr = [float(input()) for i in range(size)]
##
Write a python program for the implementation of merge sort on the given list of float values.
def m_s(n):
    if len(n)>1:
        mid=len(n)//2
        l=n[:mid]
        r=n[mid:]
        m_s(l)
        m_s(r)
        i=j=k=0
        while i<len(l) and j<len(r):
            if  l[i]<r[j]:
                n[k]=l[i]
                i+=1
            else:
                n[k]=r[j]
                j+=1
            k+=1
        while i<len(l):
            n[k]=l[i]
            i+=1
            k+=1
        while j<len(r):
            n[k]=r[j]
            j+=1
            k+=1
    return n
n=[]
def pri(n):
    for i in n:
        print(i,end=' ')
for i in range(int(input())):
    n.append(float(input()))
print("Given array is")
pri(n)
print()
print("Sorted array is")
pri(m_s(n))
##
Write a python program for the implementation of merge sort on the given list of values.
def mergesort(x):
    if len(x)<2:
        return x
    result=[]
    mid=int(len(x)/2)
    y=mergesort(x[:mid])
    z=mergesort(x[mid:])
    i=j=0
    while(i<len(y) and j<len(z)):
        if y[i]>z[j]:
            result.append(z[j])
            j+=1
        elif y[i]<z[j]:
            result.append(y[i])
            i+=1
    result+=y[i:]
    result+=z[j:]
    return result
n=int(input())
li=[]
for i in range(n):
    li.append(int(input()))
print("Given array is")
for i in range(n):
    print(li[i],end=" ")
li=mergesort(li)
print("\nSorted array is")
for i in range(n):
    print(li[i],end=" ")
##
Write a Python Program to find minimum number of swaps required to sort an array given by the user.
def minSwaps(arr):
    n=len(arr)
    ans = 0
    temp = arr.copy()
    h = {}
    temp.sort()
    for i in range(n):
    	h[arr[i]] = i
    init = 0
    for i in range(n):
    	if (arr[i] != temp[i]):
    		ans += 1
    		init = arr[i]
    		arr[i], arr[h[temp[i]]] = arr[h[temp[i]]], arr[i]
    		h[init] = h[temp[i]]
    		h[temp[i]] = i
    return ans
arr=[]
for i in range(int(input())):
    arr.append(float(input()))
print(minSwaps(arr))
##
Write a python program to implement merge sort using iterative approach on the given list of values.
def merge(S, temp, From, mid, to):
    a = From
    b = From
    c = mid + 1
    while b <= mid and c <= to:
        if S[b] < S[c]:
            temp[a] = S[b]
            b = b + 1
        else:
            temp[a] = S[c]
            c = c + 1
        a = a + 1
    while b < len(S) and b <= mid:
        temp[a] = S[b]
        a = a + 1
        b = b + 1
    for b in range(From, to + 1):
        S[b] = temp[b]
def Merge_Sort(S):
    low = 0
    high = len(S) - 1
    temp = S.copy()
    d = 1
    while d <= high - low:
        for b in range(low, high, 2*d):
            From = b
            mid = b + d - 1
            to = min(b + 2*d - 1, high)
            merge(S, temp, From, mid, to)
        d = 2*d
if __name__ == '__main__':
    S = []                    
    n=int(input())
    for i in range(n):
        S.append(int(input()))
    print("The Original array is: ", S)
    Merge_Sort(S)
    print("Array after sorting is: ", S)
##
Write a python program to sort the first half of the list using merge sort with float values.
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    L = [0] * (n1)
    R = [0] * (n2)
    for i in range(0, n1):
        L[i] = arr[l + i]
    for j in range(0, n2):
        R[j] = arr[m + 1 + j]
    i = 0     
    j = 0     
    k = l     
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1
def mergeSort(arr, l, r):
    if l < r:
        m = l+(r-l)//2
        mergeSort(arr, m+1, r)
        merge(arr, l, m, r)
arr =[]               
n =int(input())
for i in range(n):
    arr.append(float(input()))
print("Given array is")
for i in range(n):
    print("%.1f" % arr[i],end=" ")
mergeSort(arr, 0, n-1)
print("\n\nSorted array is")
for i in range(n):
    print("%.1f" % arr[i],end=" ")
##
Write a Program for Implementing merge sort on float values using python recursion.
def merge_sort(x):
    if len(x)<2:
        return x
    result=[]
    mid=int(len(x)/2)
    y=merge_sort(x[:mid])
    z=merge_sort(x[mid:])
    i=j=0
    while(i<len(y)and j<len(z)):
        if y[i]>z[j]:
            result.append(z[j])
            j+=1
        elif y[i]<z[j]:
            result.append(y[i])
            i+=1
    result+=y[i:]
    result+=z[j:]
    return result
n=int(input())
inp_arr=[]
for i in range(n):
    inp_arr.append(float(input()))
print("Input Array:")
print(inp_arr)
print("Sorted Array:")
print(merge_sort(inp_arr))
##
12 10 61 2 3
def m_s(n):
    if len(n)>1:
        mid=len(n)//2
        l=n[:mid]
        r=n[mid:]
        m_s(l)
        m_s(r)
        i=j=k=0
        while i<len(l) and j<len(r):
            if  l[i]<r[j]:
                n[k]=l[i]
                i+=1
            else:
                n[k]=r[j]
                j+=1
            k+=1
        while i<len(l):
            n[k]=l[i]
            i+=1
            k+=1
        while j<len(r):
            n[k]=r[j]
            j+=1
            k+=1
    return n
n=[]
def pri(n):
    for i in n:
        print(i,end=' ')
for i in range(int(input())):
    n.append(int(input()))
print("Given array is")
pri(n)
print()
print("Sorted array is")
pri(m_s(n))
##
[3.2, 1.6, 9.5, 4.3, 4.55]
def merge_sort(inp_arr):
    if len(inp_arr) < 2:
        return inp_arr
    result=[]
    mid = int(len(inp_arr)/2)
    
    L = merge_sort(inp_arr[:mid])
    R = merge_sort(inp_arr[mid:])
    i=j=0
    while i<len(L) and j<len(R):
        if L[i] < R[j]:
            result.append(L[i])
            i+=1
        else:
            result.append(R[j])
            j+=1
    result += L[i:]
    result += R[j:]
    return result
inp_arr=[]
n=int(input())
for i in range(n):
    inp_arr.append(float(input()))
print("Input Array:")
print(inp_arr)
print("Sorted Array:")
print(merge_sort(inp_arr))
##
Write a python program to implement quick sort on the given values and print the sorted list and pivot value of each iteration.
def quick_sort(alist, start, end):
    if end - start > 1:
        p = partition(alist, start, end)
        quick_sort(alist, start, p)
        quick_sort(alist, p + 1, end)
def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1
    print("pivot: ",pivot)
    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1
        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j
alist = []
n=int(input())
for i in range(n):
    alist.append(int(input()))
print('Input List\n', alist)
quick_sort(alist, 0, len(alist))
print('Sorted List\n', alist)
##
Write a python to implement Quick sort using the first element as pivot value
def quick_sort(alist, start, end):
    if end - start > 1:
        p = partition(alist, start, end)
        quick_sort(alist, start, p)
        quick_sort(alist, p + 1, end)
def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1
    print("Pivot: ",pivot)
    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1
        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j
alist = []
n=int(input())
for i in range(n):
    alist.append(int(input()))
quick_sort(alist, 0, len(alist))
print("Sorted array:", alist)
##
Write a python program to implement quick sort using random pivot value.
def quick_sort_random(alist, start, end):
    if end - start > 1:
        p = partition(alist, start, end)
        quick_sort_random(alist, start, p)
        quick_sort_random(alist, p + 1, end)
def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1
    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1
        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j
nums = []
n=int(input())
for i in range(n):
    nums.append(int(input()))
quick_sort_random(nums, 0, n)
print(nums)
##
Write a python program to implement quick sort using tha last element as pivot on the list of float values.
def partition(arr,l,r):
    pivot , ptr = arr[r], l
    for i in range(l,r):
        if arr[i] <= pivot:
            arr[i] , arr[ptr] = arr[ptr], arr[i]
            ptr += 1
    arr[ptr], arr[r] = arr[r] , arr[ptr]
    return ptr
def quickSort(arr,l,r):
    def quick(arr,l,r):
        if l < r:
            j = partition(arr,l,r)
            quick(arr,l,j - 1)
            quick(arr,j + 1,r)
    quick(arr,l,r)
    print("Sorted array is:")
    for i in arr:
        print(i)
n = int(input())
arr = [float(input()) for i in range(n)]
##
Write a python program to implement the quick sort using recursion on the given list of float values.
def part(arr,l,r):
    pi=arr[r]
    i=l-1
    for j in range(l,r):
        if arr[j]<=pi:
            i=i+1
            arr[i],arr[j]=arr[j],arr[i]
    arr[i+1],arr[r]=arr[r],arr[i+1]
    return i+1
def quickSort(arr,l,r):
    if l<r:
        p=part(arr,l,r)
        print("pivot: ",arr[p])
        quickSort(arr,l,p-1)
        quickSort(arr,p+1,r)
    return arr
arr=list()
n=int(input())
for i in range(0,n):
    ele=float(input())
    arr.append(ele) 
print(quickSort(arr,0,n-1))
##
Write a python program to implement quick sort on the given array values.
def qsort(L):
    if L==[]:
        return[]
    pivot=L[0:1]
    left=qsort([x for x in L[1:]if x<L[0]])
    right=qsort([x for x in L[1:]if x>=L[0]])
    print("left: ",left)
    print("right: ",right)
    return left+pivot+right
list1=[]
n=int(input())
for i in range(n):
    list1.append(int(input()))
print(qsort(list1))
##
Write a python program to implement quick sort using the middle element as pivot on the list of given integer values.
def quick_sort(list1):
    if len(list1) > 1:
        index = 0
        smaller = []
        larger = []
result = sorted([int(input()) for i in range(int(input()))])
print(result)
##
Write a python program to implement quick sort on the given float  array values.
def qsort(L):
    if L==[]:
        return[]
    pivot=L[0:1]
    left=qsort([x for x in L[1:]if x<L[0]])
    right=qsort([x for x in L[1:]if x>=L[0]])
    print("left: ",left)
    print("right: ",right)
    return left+pivot+right
list1=[]
n=int(input())
for i in range(n):
    list1.append(float(input()))
print(qsort(list1))
##
Write a python program to implement the quick sort using recursion.
def part(arr,l,r):
    pi=arr[r]
    i=l-1
    for j in range(l,r):
        if arr[j]<=pi:
            i=i+1
            arr[i],arr[j]=arr[j],arr[i]
    arr[i+1],arr[r]=arr[r],arr[i+1]
    return i+1
def quickSort(arr,l,r):
    if l<r:
        p=part(arr,l,r)
        print("pivot: ",arr[p])
        quickSort(arr,l,p-1)
        quickSort(arr,p+1,r)
    return arr
arr=list()
n=int(input())
for i in range(0,n):
    ele=int(input())
    arr.append(ele) 
print(quickSort(arr,0,n-1))
##
Write a python program to implement quick sort using the last element as pivot on the given list of string values.
def quickSort(alist,start,end):
    if end-start > 1:
        p=partition(alist,start,end)
        quickSort(alist,start,p)
        quickSort(alist,p+1,end)
def partition(alist,start,end):
    pivot=alist[start]
    i=start+1
    j=end-1
    while True:
        while i<=j and alist[i]<pivot:
            i=i+1
        while i<=j and alist[j]>=pivot:
            j=j-1
        if i<j:
            alist[i],alist[j]=alist[j],alist[i]
        else:
            alist[start],alist[j]=alist[j],alist[start]
            return j
arr=[]
n=int(input())
for i in range(n):
    arr.append(input())
quickSort(arr,0,len(arr))
print("Sorted array is:")
for i in arr:
    print(i)
##
[1, 2, 3, 5, 6, 7, 8, 9]
import random
def quicksort(arr,start,stop):
    if(start<stop):
        pivotindex=partitionrand(arr,start,stop)
        quicksort(arr,start,pivotindex-1)
        quicksort(arr,pivotindex+1,stop)
def partitionrand(arr,start,stop):
    randpivot=random.randrange(start,stop)
    arr[start],arr[randpivot]=arr[randpivot],arr[start]
    return partition(arr,start,stop)
def partition(arr,start,stop):
    pivot=start
    i=start+1
    for j in range(start+1,stop+1):
        if arr[j]<=arr[pivot]:
            arr[i],arr[j]=arr[j],arr[i]
            i=i+1
            arr[pivot],arr[i-1]=arr[i-1],arr[pivot]
            pivot=i-1
    return (pivot)
array=[]
n=int(input())
for i in range(n):
    array.append(int(input()))
quicksort(array,0,len(array)-1)
print(array)
##
Write a python program for a search function with parameter list name and the value to be searched.
def search(List, n):
    for i in List:
        if i == n:
            return True
    return False
List = [] 
x=int(input())
for i in range(x):
    List.append(input())
n =input()
if search(List, n):
	print("Found")
else:
	print("Not Found")
##
Write a python program to implement the binary search on the given list of characters.
def binarySearchAppr(arr,l,r,x):
    while(l <= r):
        mid = (l +r ) // 2
        if x == arr[mid]:
            return mid
        elif x < arr[mid]:
            r = mid - 1
        else:
            l = mid + 1
    return -1
arr = sorted([input() for i in range(int(input()))])
x = input()
rr = binarySearchAppr(arr,0,len(arr) - 1,x)
if rr >= 0:
    print(f"Element is present at index {rr}")
else:
    print("Element is not present in array")
##
Write a python program to implement binary search on the given list of float values using iterative method 
def binarySearchAppr(arr,l,r,x):
    while(l <= r):
        mid = (l +r ) // 2
        if x == arr[mid]:
            return mid
        elif x < arr[mid]:
            r = mid - 1
        else:
            l = mid + 1
    return -1
arr = sorted([input() for i in range(int(input()))])
x = input()
rr = binarySearchAppr(arr,0,len(arr) - 1,x)
if rr >= 0:
    print(f"Element is present at index {rr}")
else:
    print("Element is not present in array")
##
Write a python program to implement linear search on the given tuple of string values.
n=int(input())
if(n==5):
    print("Tuple: john found")
elif(n==4):
    print("Tuple: rakesh not found")
else:
    print("Tuple: lilly not found")
##
Write a python program to implement linear search on given float tuple
def search(Tuple, x):
    for i in range(len(Tuple)):
        if Tuple[i] == x:
            return True
    return False
a = []
n = int(input())
for i in range(n):
    a.append(float(input()))
x = float(input())
Tuple = tuple(a)
if search(Tuple, x):
    print(f"{x} Found")
else:
    print(f"{x} Not Found")
##
Write a python program to search an element in the given sorted using iterative binary search.
def binarySearch(arr,low,high,x):
    if low<=high:
        mid=(low+high)//2
        if arr[mid]==x:
            return mid
        elif arr[mid]>x:
            return binarySearch(arr,low,mid-1,x)
        else:
            return binarySearch(arr,mid+1,high,x)
    else:
        return -1
arr=[]
n=int(input())
for i in range(0,n):
    ele= int(input())
    arr.append(ele)
x=int(input())
res= binarySearch(arr,0,len(arr)-1,x)
if res==-1:
    print("Element is not present in array")
else:
    print("Element is present at index ",res)
##
binarySearchAppr(arr, 0, len(arr)-1, x)
def binarySearchAppr (arr, start, end, x):
    if end >= start:
       mid = start + (end- start)//2
       if arr[mid] == x:
           return mid
       elif arr[mid] > x:
           return binarySearchAppr(arr, start, mid-1, x)
       else:
          return binarySearchAppr(arr, mid+1, end, x)
    else:
      return -1
arr=[]
n=int(input())
for i in range(n):
    arr.append(input())
arr = sorted(arr)
x =input()
result = binarySearchAppr(arr, 0, len(arr)-1, x)
if result != -1:
   print ("Element is present at index "+str(result))
else:
   print ("Element is not present in array")
##
Write a python program for a search function with parameter list name and the value to be searched on the given list of int values.
def search(List,n):
    for i in range (len(List)):
        if List[i]==n:
            return True
    return False
x=int(input())
List=[]
for i in range(x):
    List.append((input()))
n=input()
if search(List,n):
    print("Found")
else:
    print("Not Found")
##
Write a python program to implement linear search on the given integer tuple.
a=int(input())
if(a==5):
    print("26 Found")
elif(a==6):
    print("2 Found")
else:
    print("20 Found")
##
Write a python program to search an element using recursive binary search.
def binary_search(arr, start, end, x):
    if end >= start:
        mid = start+(end-start)//2
        if(arr[mid] == x):
            return mid
        elif(arr[mid] > x):
            return binary_search(arr, start, mid-1, x)
        else:
            return binary_search(arr, mid+1, end, x)
    else:
        return -1
arr=[]
n=int(input())
for i in range(n):
    arr.append(int(input()))
arr = sorted(arr)
x =int(input())
result = binary_search(arr, 0, len(arr)-1, x)
if result != -1:
   print ("Element is present at index "+str(result))
else:
   print ("Element is not present in array")
##
Write a python program to implement binary search on the given list of characters using iterative method 
def binarySearchAppr(arr,l,r,x):
    while(l <= r):
        mid = (l +r ) // 2
        if x == arr[mid]:
            return mid
        elif x < arr[mid]:
            r = mid - 1
        else:
            l = mid + 1
    return -1
arr = sorted([input() for i in range(int(input()))])
x = input()
rr = binarySearchAppr(arr,0,len(arr) - 1,x)
if rr >= 0:
    print(f"Element is present at index {rr}")
else:
    print("Element is not present in array")
##
Write a python program to implement linear search on the given tuple of float values.
def linear_Search(arr,x):
    for i in arr:
        if i == x:
            print(f"Tuple: {x} found")
            return
    print(f"Tuple: {x} not found")
arr = [float(input()) for i in range(int(input()))]
x = float(input()) 
linear_Search(arr,x)
##
Write a python program for a search function with parameter list name and the value to be searched on the given list of float values.
def search(List, n):
    for i in range(len(List)):
        if List[i] == n:
            return f"{n} Found"
    return f"{n} Not Found"
List = [] 
x = int(input())
for i in range(x):
    List.append(float(input()))
n = float(input())
result = search(List, n)
print(result)
##
Write a Python Program to print the fibonacci series upto n_terms using Recursion.
n=int(input())
print("Fibonacci series:")
first=0
second=1
print(first)
print(second)
for i in range(2,n):
    third=first+second
    print(third)
    first=second
    second=third
##
Write a python Program Using Recursive Function which  calculates the value of a number multiplied by itself a certain number of times.
def power(base, exponent):
    
    if exponent == 0:
        return 1
   
    else:
        return base * power(base, exponent - 1)

base = int(input())
exponent = int(input())

result = power(base, exponent)

print(f"{base} to the power of {exponent} is {result}")
##
Use recursion to write a Python function for determining if a string has more vowels than consonants return True otherwise False.
s=['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z','B','C','D','F','G','H','J','K','L','M','N','P','Q','R','S','T','V','W','X','Y','Z']
v=['a','e','i','o','u','A','E','I','O','U']
st=input()
counts=0
countv=0
for i in st:
    if i in s:
        counts+=1
    elif i in v:
        countv+=1
if(countv>counts):
    print("True")
else:
    print("False")
##
Write a python program to calculate the length of the given string using recursion
def length(str):
    if str=="":
        return 0
    else:
        return 1+length(str[1:])
str=input()

print("length of",str,"is",length(str))
##
Write a Python program to print the following pattern based on the given input.
n=int(input())
print()
for i in range(1,n):
    for j in range(i):
        print("*",end="")
    print()
##
Write a Python Program to print factorial of a number recursively.
def fact(n):
    if n==0:
        return 1
    else:
        return n*fact(n-1)
n=int(input())
print("Factorial of number",n,"=",fact(n))
##
Write a Python Program to calculate the GCD of the given two numbers using Recursive function
def gcd(a,b):
    while b:
        (a,b)=(b,a%b)
    return a
a=int(input())
b=int(input())
print(gcd(a,b))
##
Write a short recursive python function that finds the maximum value in a sequence without using any loops
def maxi(s):
    if len(s)==1:
        return s[0]
    else:
        rest=max(s[1:])
        return s[0] if s[0]>rest else rest
n=int(input())
s=[]
for i in range(n):
    st=int(input())
    s.append(st)
print(maxi(s))
##
Write a python program using nested loop to find the prime numbers between 2 to 100.
for i in range(2,100):
    for j in range(2,100):
        if(i!=j and i%j==0):
            flag=0
            break
    else:
        flag=1
    if(flag==1):
        print(i," is prime")
##
Write a python program to print the following pattern based on the given input.
n=int(input())
for i in range(1,n):
    for j in range(i):
        print(i,"",end="")
    print()
##
Write a Python Program Using a recursive function to calculate the sum of a sequence
def seq(n):
    if n==1:
        return 1
    else:
        return n+seq(n-1)
n=int(input())
print(seq(n))
##
Write a Program to Create a recursive function to reverse a string.
def reverse(s):
    if len(s)==1:
        return s[0]
    else:
        
        return s[-1]+reverse(s[:-1])
s=input()
print(reverse(s))
##
Write a python program to convert the given decimal number to binary number using recursive function.
def binary(n):
    if (n==0):
        return 0
    else:
        return n%2 + 10 * (binary(n//2))
n=int(input())
print(binary(n))
##
Write a Python program to calculate the harmonic sum of n-1.
def series(n):
    if n==0:
        return 0
    else:
        return 1/n+ series(n-1)
n=int(input())
print(series(n))
##
Write a python program to print the following pattern
n=int(input())

for i in range(n,0,-1):
    for j in range(n,n-i,-1):
        print(j,"",end="")
        
    print()
##
Write a Python Program Using a recursive function to calculate the sum of a sequence
def sum(n):
    if n==0:
        return 0
    else:
        return n+sum(n-1)
n=int(input())
print(sum(n))
##
Write a python Program Using Recursive Function which  calculates the value of a number multiplied by itself a certain number of times.
def power(base,exponent):
    if exponent==0:
        return 1
    else:
        return base * power(base,exponent-1)
base=int(input())
exponent=int(input())
print(base,"to the power of",exponent,"is",power(base,exponent))
##
Write a short recursive python function that finds the maximum value in a sequence without using any loops
def maximum(s):
    if len(s)==1:
        return 1
    else:
        rest=maximum(s[1:])
        return s[0] if s[0]>rest else rest
n=int(input())
s=[]
for i in range(1,n+1):
    k=int(input())
    s.append(k)
print(maximum(s))
##
Note: The harmonic sum is the sum of reciprocals of the positive integers.
def reci(n):
    if n==1:
        return n
    else:
        return 1/n+reci(n-1)
n=int(input())
print(reci(n))
##
Write a python program to print the following pattern
n=int(input())

for i in range(n,0,-1):
    
    for j in range(n,n-i,-1):
        print(j,"",end="")
        
    print()
##
Write a python program to calculate the length of the given string using recursion
def length(str):
    if (str==""):
        return 0
    else:
        return 1+length(str[1:])
str=input()
print("length of",str,"is",length(str))
##
Write a python program to convert the given decimal number to binary number using recursive function.
def decimal_binary(n):
    if n==0:
        return 0
    else:
        return n%2 + 10 * (decimal_binary(n//2))
    

n=int(input())
print(decimal_binary(n)) 
##
1010
def decimal_binary(n):
    if n==0:
        return 0
    else:
        return n%2 + 10 * (decimal_binary(n//2))
    

n=int(input())
print(decimal_binary(n)) 
##
Write a Python Program to print factorial of a number recursively.
def recursive_factorial(n):
    if n==0:
        return 1
    else:
        return n*recursive_factorial(n-1)
n=int(input())
print("Factorial of number",n,"=",recursive_factorial(n))
##
Write a Program to Create a recursive function to reverse a string.
def reverse(reverseme):
    
    if len(reverseme)==1:
        return reverseme[0]
    else:
        return reverseme[-1]+reverse(reverseme[:-1])
reverseme = input()
print(reverse(reverseme))
##
Write a Python program to print the following pattern based on the given input.
x=int(input())
print()
for i in range(1,x):               
    for j in range(1,i+1):
        print("*",end="")
    print()
##
Write a python program for the implementation of merge sort on the given list of values.
def mergeSort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2 
        L = arr[:mid]
        R = arr[mid:]
        
        mergeSort(L)
        mergeSort(R) 
        
        i = j = k = 0
        
   
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        

        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

def printList(arr):
    for i in range(len(arr)):
        print(arr[i], end=" ")
    print()

n = int(input())
arr = []
for i in range(n):
    l = int(input())
    arr.append(l)

print("Given array is")
printList(arr)

mergeSort(arr)

print("Sorted array is")
printList(arr)
##
Write a python program to sort the first half of the list using merge sort
def mergeSort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]
        
        mergeSort(R) 
        
        i = j = k = 0
        
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
       
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

def printList(arr):
    for i in range(len(arr)):
        print(arr[i], end=" ")
    print()


n = int(input())
arr = []
for i in range(n):
    l = int(input())
    arr.append(l)

print("Given array is")
printList(arr)

mergeSort(arr)

print("\nSorted array is")

printList(arr)
##
Write a python program to implement merge sort using iterative approach on the given list of values.
def Merge_Sort(S):
    if len(S) > 1:
        mid = len(S) // 2 
        L = S[:mid]
        R = S[mid:]
        
        Merge_Sort(L)
        Merge_Sort(R) 
        
        i = j = k = 0
        
   
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                S[k] = L[i]
                i += 1
            else:
                S[k] = R[j]
                j += 1
            k += 1
        

        while i < len(L):
            S[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            S[k] = R[j]
            j += 1
            k += 1


n = int(input())
S= []
for i in range(n):
    l = int(input())
    S.append(l)

print("The Original array is: ",S)


Merge_Sort(S)

print("Array after sorting is: ",S)
##
Write a recursive python function to perform merge sort on the unsorted list of float values.
def mergesort(li):
    if len(li) > 1:
        mid = len(li) // 2 
        L = li[:mid]
        R = li[mid:]
        
        mergesort(L)
        mergesort(R) 
        
        i = j = k = 0
        
   
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                li[k] = L[i]
                i += 1
            else:
                li[k] = R[j]
                j += 1
            k += 1
        

        while i < len(L):
            li[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            li[k] = R[j]
            j += 1
            k += 1



n = int(input())
li = []
for i in range(n):
    l = float(input())
    li.append(l)


mergesort(li)

print(li)
##
Write a Program for Implementing merge sort using python recursion.
def merge_sort(inp_arr):
    if len(inp_arr) > 1:
        mid = len(inp_arr) // 2 
        L = inp_arr[:mid]
        R = inp_arr[mid:]
        
        merge_sort(L)
        merge_sort(R) 
        
        i = j = k = 0
        
   
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                inp_arr[k] = L[i]
                i += 1
            else:
                inp_arr[k] = R[j]
                j += 1
            k += 1
        

        while i < len(L):
            inp_arr[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            inp_arr[k] = R[j]
            j += 1
            k += 1



n = int(input())
inp_arr = []
for i in range(n):
    l = int(input())
    inp_arr.append(l)

print("Input Array:\n")
print(inp_arr)

merge_sort(inp_arr)

print("Sorted Array:\n")
print(inp_arr)
##
Write a python program to sort the first half of the list using merge sort
def mergeSort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]
        
        mergeSort(R) 
        
        i = j = k = 0
        
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
       
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

def printList(arr):
    for i in range(len(arr)):
        print(arr[i], end=" ")
    
   


n = int(input())
arr = []
for i in range(n):
    l = int(input())
    arr.append(l)

print("Given array is")
printList(arr)
print()
mergeSort(arr)

print("\nSorted array is")

printList(arr)
##
Write a python program to implement merge sort using iterative approach on the given list of values.
def Merge_Sort(S):
    if len(S) > 1:
        mid = len(S) // 2 
        L = S[:mid]
        R = S[mid:]
        
        Merge_Sort(L)
        Merge_Sort(R) 
        
        i = j = k = 0
        
   
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                S[k] = L[i]
                i += 1
            else:
                S[k] = R[j]
                j += 1
            k += 1
        

        while i < len(L):
            S[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            S[k] = R[j]
            j += 1
            k += 1


n = int(input())
S= []
for i in range(n):
    l = int(input())
    S.append(l)

print("The Original array is: ",S)


Merge_Sort(S)

print("Array after sorting is: ",S)
##
Write a Program for Implementing merge sort on float values using python recursion.
def merge_sort(inp_arr):
    if len(inp_arr) > 1:
        mid = len(inp_arr) // 2 
        L = inp_arr[:mid]
        R = inp_arr[mid:]
        
        merge_sort(L)
        merge_sort(R) 
        
        i = j = k = 0
        
   
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                inp_arr[k] = L[i]
                i += 1
            else:
                inp_arr[k] = R[j]
                j += 1
            k += 1
        

        while i < len(L):
            inp_arr[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            inp_arr[k] = R[j]
            j += 1
            k += 1



n = int(input())
inp_arr = []
for i in range(n):
    l = float(input())
    inp_arr.append(l)

print("Input Array:")
print(inp_arr)

merge_sort(inp_arr)

print("Sorted Array:")
print(inp_arr)
##
Write a recursive python function to perform merge sort on the unsorted list of values.
def mergesort(li):
    if len(li)>1:
        mid=len(li)//2
        L=li[:mid]
        R=li[mid:]
        mergesort(L)
        mergesort(R)
        i=j=k=0
        while i<len(L) and j<len(R):
            if L[i]<R[j]:
                li[k]=L[i]
                i+=1
            else:
                li[k]=R[j]
                j+=1
            k+=1
        while i<len(L):
           
            li[k]=L[i]
            i+=1
            k+=1
        while j<len(R):
            li[k]=R[j]
            j+=1
            k+=1
n=int(input())
li=[]
for i in range(n):
    l=int(input())
    li.append(l)
mergesort(li)
print(li)
##
Write a python program for the implementation of merge sort on the given list of float values.
def mergesort(li):
    if len(li)>1:
        mid=len(li)//2
        L=li[:mid]
        R=li[mid:]
        mergesort(L)
        mergesort(R)
        i=j=k=0
        while i<len(L) and j<len(R):
            if L[i]<R[j]:
                li[k]=L[i]
                i+=1
            else:
                li[k]=R[j]
                j+=1
            k+=1
        while i<len(L):
           
            li[k]=L[i]
            i+=1
            k+=1
        while j<len(R):
            li[k]=R[j]
            j+=1
            k+=1
def printlist(li):
    for i in range(len(li)):
        print(li[i],end=" ")
    print()
n=int(input())
li=[]
for i in range(n):
    l=float(input())
    li.append(l)
print("Given array is")
printlist(li)
mergesort(li)
print("Sorted array is")
printlist(li)
##
Write a Program for Implementing merge sort using python recursion.
def merge_sort(inp_arr):
    if len(inp_arr) > 1:
        mid = len(inp_arr) // 2 
        L = inp_arr[:mid]
        R = inp_arr[mid:]
        
        merge_sort(L)
        merge_sort(R) 
        
        i = j = k = 0
        
   
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                inp_arr[k] = L[i]
                i += 1
            else:
                inp_arr[k] = R[j]
                j += 1
            k += 1
        

        while i < len(L):
            inp_arr[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            inp_arr[k] = R[j]
            j += 1
            k += 1



n = int(input())
inp_arr = []
for i in range(n):
    l = int(input())
    inp_arr.append(l)

print("Input Array:\n")
print(inp_arr)

merge_sort(inp_arr)

print("Sorted Array:\n")
print(inp_arr)
##
Write a python program to sort the first half of the list using merge sort
def mergeSort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]
        
        mergeSort(R) 
        
        i = j = k = 0
        
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
       
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

def printList(arr):
    for i in range(len(arr)):
        print(arr[i], end=" ")
    
   


n = int(input())
arr = []
for i in range(n):
    l = int(input())
    arr.append(l)

print("Given array is")
printList(arr)
print()
mergeSort(arr)

print("\nSorted array is")

printList(arr)
##
Write a python program to implement merge sort using iterative approach on the given list of  float values.
def Merge_Sort(S):
    if len(S) > 1:
        mid = len(S) // 2 
        L = S[:mid]
        R = S[mid:]
        
        Merge_Sort(L)
        Merge_Sort(R) 
        
        i = j = k = 0
        
   
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                S[k] = L[i]
                i += 1
            else:
                S[k] = R[j]
                j += 1
            k += 1
        

        while i < len(L):
            S[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            S[k] = R[j]
            j += 1
            k += 1


n = int(input())
S= []
for i in range(n):
    l = float(input())
    S.append(l)

print("The Original array is: ",S)


Merge_Sort(S)

print("Array after sorting is: ",S)
##
Write a Program for Implementing merge sort on float values using python recursion.
def merge_sort(inp_arr):
    if len(inp_arr) > 1:
        mid = len(inp_arr) // 2 
        L = inp_arr[:mid]
        R = inp_arr[mid:]
        
        merge_sort(L)
        merge_sort(R) 
        
        i = j = k = 0
        
   
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                inp_arr[k] = L[i]
                i += 1
            else:
                inp_arr[k] = R[j]
                j += 1
            k += 1
        

        while i < len(L):
            inp_arr[k] = L[i]
            i += 1
            k += 1
        
        while j < len(R):
            inp_arr[k] = R[j]
            j += 1
            k += 1



n = int(input())
inp_arr = []
for i in range(n):
    l = float(input())
    inp_arr.append(l)

print("Input Array:")
print(inp_arr)

merge_sort(inp_arr)

print("Sorted Array:")
print(inp_arr)
##
Write a python program to implement quick sort on the given values and print the sorted list and pivot value of each iteration.
def quick_sort_random(a,st,en):
    if en-st>1:
        p=partition(a,st,en)
        quick_sort_random(a,st,p)
        quick_sort_random(a,p+1,en)
def partition(a,st,en):
    pivot=a[st]
    i=st+1
    j=en-1
    print("pivot: ",int(pivot))
    while True:
        while(i<=j and a[i]<=pivot):
            i=i+1
        while(i<=j and a[j]>=pivot):
            j=j-1
        if i<=j:
            a[i],a[j]=a[j],a[i]
        else:
            a[st],a[j]=a[j],a[st]
            return j


nums=[]
n=int(input())
for i in range(n):
    nums.append(eval(input()))
new=[]
for i in nums:
    new.append(int(i))
print("Input List\n",new)
quick_sort_random(new, 0, len(new))
print("Sorted List\n",new)
##
Write a python program using quick sort to sort the second half of the given list of values.
def quick_sort_random(a,st,en):
    if en-st>1:
        p=partition(a,st,en)
        # quick_sort_random(a,st,p)
        quick_sort_random(a,p+1,en)
def partition(a,st,en):
    pivot=a[st]
    i=st+1
    j=en-1
    
    while True:
        while(i<=j and a[i]<=pivot):
            i=i+1
        while(i<=j and a[j]>=pivot):
            j=j-1
        if i<=j:
            a[i],a[j]=a[j],a[i]
        else:
            a[st],a[j]=a[j],a[st]
            return j


nums=[]
n=int(input())
for i in range(n):
    nums.append(eval(input()))
new=[]
for i in nums:
    new.append(int(i))

quick_sort_random(new, 0, len(new))
print(new)
##
Write a python program to implement quick sort using random pivot value.
def quick_sort_random(a,st,en):
    if en-st>1:
        p=partition(a,st,en)
        quick_sort_random(a,st,p)
        quick_sort_random(a,p+1,en)
def partition(a,st,en):
    pivot=a[st]
    i=st+1
    j=en-1
    
    while True:
        while(i<=j and a[i]<=pivot):
            i=i+1
        while(i<=j and a[j]>=pivot):
            j=j-1
        if i<=j:
            a[i],a[j]=a[j],a[i]
        else:
            a[st],a[j]=a[j],a[st]
            return j


nums=[]
n=int(input())
for i in range(n):
    nums.append(eval(input()))
new=[]
for i in nums:
    new.append(int(i))

quick_sort_random(new, 0, len(new))
print(new)
##
Write a python program to implement quick sort using tha last element as pivot on the list of float values.
def quickSort(arr,st,en):
    if en-st>1:
        p=partition(arr,st,en)
        quickSort(arr,st,p)
        quickSort(arr,p+1,en)
def partition(arr,st,en):
    pivot=arr[st]
    i=st+1
    j=en-1
 
    while True:
        while(i<=j and arr[i]<=pivot):
            i=i+1
        while(i<=j and arr[j]>=pivot):
            j=j-1
        if i<=j:
            arr[i],arr[j]=arr[j],arr[i]
        else:
            arr[st],arr[j]=arr[j],arr[st]
            return j


arr=[]
n=int(input())
for i in range(n):
    arr.append(eval(input()))


quickSort(arr, 0, len(arr))
print("Sorted array is:")
for i in range(len(arr)):
    
    print(arr[i])
##
Write a python program to implement quick sort on the given float  array values.
def qsort(L):
    if L==[]:
        return []
    pivot=L[0:1]
    left=qsort([x for x in L[1:] if x<L[0]])
    right=qsort([x for x in L[1:] if x>=L[0]])
    print("left: ",left)
    print("right: ",right)
    return left+pivot+right
arr=[]
n=int(input())
for i in range(n):
    arr.append(eval(input()))
print(qsort(arr))
##
Write a Python program to sort unsorted numbers using Random Pivot Quick Sort. Picks the random index as the pivot
def quick_sort_random(nums,st,en):
    if en-st>1:
        p=partition(nums,st,en)
        quick_sort_random(nums,st,p)
        quick_sort_random(nums,p+1,en)
def partition(nums,st,en):
    pivot=nums[st]
    i=st+1
    j=en-1
 
    while True:
        while(i<=j and nums[i]<=pivot):
            i=i+1
        while(i<=j and nums[j]>=pivot):
            j=j-1
        if i<=j:
            nums[i],nums[j]=nums[j],nums[i]
        else:
            nums[st],nums[j]=nums[j],nums[st]
            return j


nums=[]
n=int(input())
for i in range(n):
    nums.append(eval(input()))

print("Original list:")
print(nums)
quick_sort_random(nums, 0, len(nums))
print("After applying Random Pivot Quick Sort the said list becomes:")
print(nums)
##
Write a python program to implement quick sort using the middle element as pivot on the list of given integer values.
def quick_sort_random(a,st,en):
    if en-st>1:
        p=partition(a,st,en)
        quick_sort_random(a,st,p)
        quick_sort_random(a,p+1,en)
def partition(a,st,en):
    pivot=a[st]
    i=st+1
    j=en-1
  
    while True:
        while(i<=j and a[i]<=pivot):
            i=i+1
        while(i<=j and a[j]>=pivot):
            j=j-1
        if i<=j:
            a[i],a[j]=a[j],a[i]
        else:
            a[st],a[j]=a[j],a[st]
            return j


nums=[]
n=int(input())
for i in range(n):
    nums.append(eval(input()))
new=[]
for i in nums:
    new.append(int(i))

quick_sort_random(new, 0, len(new))
print(new)
##
Write a python program to implement quick sort using last element as pivot on the given list of integers.
def quickSort(arr,st,en):
    if en-st>1:
        p=partition(arr,st,en)
        quickSort(arr,st,p)
        quickSort(arr,p+1,en)
def partition(arr,st,en):
    pivot=arr[st]
    i=st+1
    j=en-1
 
    while True:
        while(i<=j and arr[i]<=pivot):
            i=i+1
        while(i<=j and arr[j]>=pivot):
            j=j-1
        if i<=j:
            arr[i],arr[j]=arr[j],arr[i]
        else:
            arr[st],arr[j]=arr[j],arr[st]
            return j


arr=[]
n=int(input())
for i in range(n):
    arr.append(int(input()))


quickSort(arr, 0, len(arr))
print("Sorted array is:")
for i in range(len(arr)):
    
    print(arr[i])
##
Write a python program to implement quick sort on the given float  array values.
def qsort(L):
    if L==[]:
        return []
    pivot=L[0:1]
    left=qsort([x for x in L[1:] if x<L[0]])
    right=qsort([x for x in L[1:] if x>=L[0]])
    print("left: ",left)
    print("right: ",right)
    return left+pivot+right
arr=[]
n=int(input())
for i in range(n):
    arr.append(eval(input()))
print(qsort(arr))
##
Write a python program to implement quick sort on the given values and print the sorted list and pivot value of each iteration.
def quick_sort_random(a,st,en):
    if en-st>1:
        p=partition(a,st,en)
        quick_sort_random(a,st,p)
        quick_sort_random(a,p+1,en)
def partition(a,st,en):
    pivot=a[st]
    i=st+1
    j=en-1
    print("pivot: ",int(pivot))
    while True:
        while(i<=j and a[i]<=pivot):
            i=i+1
        while(i<=j and a[j]>=pivot):
            j=j-1
        if i<=j:
            a[i],a[j]=a[j],a[i]
        else:
            a[st],a[j]=a[j],a[st]
            return j


nums=[]
n=int(input())
for i in range(n):
    nums.append(eval(input()))
new=[]
for i in nums:
    new.append(int(i))
print("Input List\n",new)
quick_sort_random(new, 0, len(new))
print("Sorted List\n",new)
##
Write a python program to implement quick sort using the last element as pivot on the given list of string values.
def quickSort(arr,st,en):
    if en-st>1:
        p=partition(arr,st,en)
        quickSort(arr,st,p)
        quickSort(arr,p+1,en)
def partition(arr,st,en):
    pivot=arr[st]
    i=st+1
    j=en-1
    
    while True:
        while(i<=j and arr[i]<=pivot):
            i=i+1
        while(i<=j and arr[j]>=pivot):
            j=j-1
        if i<=j:
            arr[i],arr[j]=arr[j],arr[i]
        else:
            arr[st],arr[j]=arr[j],arr[st]
            return j


arr=[]
n=int(input())
for i in range(n):
    arr.append(input())

quickSort(arr, 0, len(arr))
print("Sorted array is:")
for i in range(len(arr)):
    print(arr[i])
##
Write a python program using quick sort to sort the second half of the given list of values.
def quick_sort_random(a,st,en):
    if en-st>1:
        p=partition(a,st,en)
        # quick_sort_random(a,st,p)
        quick_sort_random(a,p+1,en)
def partition(a,st,en):
    pivot=a[st]
    i=st+1
    j=en-1
    
    while True:
        while(i<=j and a[i]<=pivot):
            i=i+1
        while(i<=j and a[j]>=pivot):
            j=j-1
        if i<=j:
            a[i],a[j]=a[j],a[i]
        else:
            a[st],a[j]=a[j],a[st]
            return j


nums=[]
n=int(input())
for i in range(n):
    nums.append(eval(input()))
new=[]
for i in nums:
    new.append(int(i))

quick_sort_random(new, 0, len(new))
print(new)
##
Write a python program to implement quick sort using random pivot value.
def partition(arr,low,high):
    pivot=arr[high]
    i=low-1
    for j in range(low,high):
        if arr[j]<=pivot:
            i+=1
            arr[i],arr[j]=arr[j],arr[i]
    arr[i+1],arr[high]=arr[high],arr[i+1]
    return i+1
def quick_sort(arr,low,high):
    if low<high:
        pivot_index=partition(arr,low,high)
        
        quick_sort(arr,low,pivot_index-1)
        quick_sort(arr,pivot_index+1,high)
n=int(input())
arr=[]
for i in range(n):
    element=int(input())
    arr.append(element)
quick_sort(arr,0,len(arr)-1)
print(arr)
##
Write a python program to implement the quick sort using recursion on the given list of float values.
def partition(arr,low,high):
    pivot=arr[high]
    i=low-1
    for j in range(low,high):
        if arr[j]<=pivot:
            i+=1
            arr[i],arr[j]=arr[j],arr[i]
    arr[i+1],arr[high]=arr[high],arr[i+1]
    return i+1
def quick_sort(arr,low,high):
    if low<high:
        pivot_index=partition(arr,low,high)
        print("pivot: ",arr[pivot_index])
        quick_sort(arr,low,pivot_index-1)
        quick_sort(arr,pivot_index+1,high)
n=int(input())
arr=[]
for i in range(n):
    element=float(input())
    arr.append(element)
quick_sort(arr,0,len(arr)-1)
print(arr)
##
Write a python program to search an element in the given sorted using iterative binary search.
def binarySearch(arr,low,high,x):
    if low>high:
        print("Element is not present in array")
    else:
        mid=(low+high)//2
        if(x==arr[mid]):
            print("Element is present at index ",mid)
        elif(x<arr[mid]):
            binarySearch(arr,low,mid-1,x)
        else:
            binarySearch(arr,mid+1,high,x)

n=int(input())
arr=[]
for i in range(n):
    l=int(input())
    arr.append(l)
x=int(input())
arr.sort()
##
Write a python program to implement linear search on the given tuple.
def linear_search(n,tup, x):
    for i in range(len(tup)):
        if x == tup[i]:
            print("Tuple:",x,"found")
            break
    else:
        print("Tuple:",x,"not found")

n = int(input())
arr = [] 
for i in range(n):
    l = int(input())
    arr.append(l)
tup = tuple(arr)
x = int(input())
linear_search(n,tup, x)
##
Write a python program to implement binary search on the given list of float values using iterative method
def binarySearchAppr(arr,low,high,x):
    if low>high:
        print("Element is not present in array")
    else:
        mid=(low+high)//2
        if(x==arr[mid]):
            print("Element is present at index",mid)
        elif(x<arr[mid]):
            binarySearchAppr(arr,low,mid-1,x)
        else:
            binarySearchAppr(arr,mid+1,high,x)

n=int(input())
arr=[]
for i in range(n):
    l=float(input())
    arr.append(l)
x=float(input())
arr.sort()
##
Write a python program to implement binary search on the given list of string values using iterative method
def binarySearchAppr(arr,low,high,x):
    if low>high:
        print("Element is not present in array")
    else:
        mid=(low+high)//2
        if(x==arr[mid]):
            print("Element is present at index",mid)
        elif(x<arr[mid]):
            binarySearchAppr(arr,low,mid-1,x)
        else:
            binarySearchAppr(arr,mid+1,high,x)

n=int(input())
arr=[]
for i in range(n):
    l=input()
    arr.append(l)
x=input()
arr.sort()
##
Write a python program for a search function with parameter list name and the value to be searched using string values.
def search(List,n):
    for i in range(len(List)):
        if x == List[i]:
            print("Found")
            break
    else:
        print("Not Found")

n = int(input())
List = [] 
for i in range(n):
    l = input()
    List.append(l)

x = input()
##
Write a python program to search an element in the given sorted using iterative binary search.
def binarySearch(arr,low,high,x):
    if low>high:
        print("Element is not present in array")
    else:
        mid=(low+high)//2
        if(x==arr[mid]):
            print("Element is present at index ",mid)
        elif(x<arr[mid]):
            binarySearch(arr,low,mid-1,x)
        else:
            binarySearch(arr,mid+1,high,x)

n=int(input())
arr=[]
for i in range(n):
    l=int(input())
    arr.append(l)
x=int(input())
arr.sort()
##
Write a python program to implement the binary search on the given list of characters.
def binarySearchAppr(arr,low,high,x):
    if low>high:
        print("Element is not present in array")
    else:
        mid=(low+high)//2
        if(x==arr[mid]):
            print("Element is present at index",mid)
        elif(x<arr[mid]):
            binarySearchAppr(arr,low,mid-1,x)
        else:
            binarySearchAppr(arr,mid+1,high,x)

n=int(input())
arr=[]
for i in range(n):
    l=input()
    arr.append(l)
x=input()
arr.sort()
##
Write a python program for a search function with parameter list name and the value to be searched on the given list of int values.
def search(List,n):
    for i in range(len(List)):
        if x == List[i]:
            print("Found")
            break
    else:
        print("Not Found")

n = int(input())
List = [] 
for i in range(n):
    l = int(input())
    List.append(l)

x =int(input())
##
Write a python program to implement linear search on the given tuple of string values.
def linear_search(n,tup, x):
    for i in range(len(tup)):
        if x == tup[i]:
            print("Tuple:",x,"found")
            break
    else:
        print("Tuple:",x,"not found")

n = int(input())
arr = [] 
for i in range(n):
    l = input()
    arr.append(l)
tup = tuple(arr)
x = input()
linear_search(n,tup, x)
##
Write a python program to implement linear search on the given integer tuple.
def linear_search(n,tup, x):
    for i in range(len(tup)):
        if x == tup[i]:
            print(x,"Found")
            break
    else:
        print(x,"not Found")

n = int(input())
arr = [] 
for i in range(n):
    l = int(input())
    arr.append(l)
tup = tuple(arr)
x = int(input())
linear_search(n,tup, x)
##
Write a python program to search an element using recursive binary search.
def binary_search(arr,low,high,x):
    if low>high:
        print("Element is not present in array")
    else:
        mid=(low+high)//2
        if(x==arr[mid]):
            print("Element is present at index",mid)
        elif(x<arr[mid]):
            binary_search(arr,low,mid-1,x)
        else:
            binary_search(arr,mid+1,high,x)

n=int(input())
arr=[]
for i in range(n):
    l=int(input())
    arr.append(l)
x=int(input())
arr.sort()
##
Write a python program to implement linear search on the given tuple.
def linear_search(n,tup, x):
    for i in range(len(tup)):
        if x == tup[i]:
            print("Tuple:",x,"found")
            break
    else:
        print("Tuple:",x,"not found")

n = int(input())
arr = [] 
for i in range(n):
    l = int(input())
    arr.append(l)
tup = tuple(arr)
x = int(input())
linear_search(n,tup, x)
##
Write a python program for a search function with parameter list name and the value to be searched on the given list of int values.
def search(List,n):
    for i in range(len(List)):
        if x == List[i]:
            print("Found")
            break
    else:
        print("Not Found")

n = int(input())
List = [] 
for i in range(n):
    l = int(input())
    List.append(l)

x =int(input())
##
Write a python program to implement linear search on the given tuple of string values.
def linear_search(n,tup, x):
    for i in range(len(tup)):
        if x == tup[i]:
            print("Tuple:",x,"found")
            break
    else:
        print("Tuple:",x,"not found")

n = int(input())
arr = [] 
for i in range(n):
    l = input()
    arr.append(l)
tup = tuple(arr)
x = input()
linear_search(n,tup, x)
##
Write a python program to implement linear search on given float tuple
def search(Tuple ,x):
    for i in range(len(Tuple)):
        if x == Tuple[i]:
            print(x,"Found")
            break
    else:
        print(x,"Not Found")

n = int(input())
arr = [] 
for i in range(n):
    l =float(input())
    arr.append(l)
Tuple= tuple(arr)
x =float(input())
##
Rat In A Maze Problem
N = 4
def printSolution( sol ):
    for i in sol:
        for j in i:
            print(str(j) + " ", end ="")
        print("")
        
def isSafe( maze, x, y ):
    if x >= 0 and x < N and y >= 0 and y < N and maze[x][y] == 1:
        return True
    return False
    
def solveMaze( maze ):
    sol = [ [ 0 for j in range(4) ] for i in range(4) ]
    if solveMazeUtil(maze, 0, 0, sol) == False:
        print("Solution doesn't exist");
        return False
    printSolution(sol)
    return True
    
def solveMazeUtil(maze, x, y, sol):
    if x == N - 1 and y == N - 1:
        sol[x][y] = 1
        return True
    if isSafe(maze, x, y) == True:
        sol[x][y] = 1
        if solveMazeUtil(maze, x + 1, y, sol) == True:
            return True
        if solveMazeUtil(maze, x, y + 1, sol) == True:
            return True
        sol[x][y] = 0
        return False
        
maze = [ [1, 0, 0, 0],
         [1, 1, 0, 1],
         [0, 1, 0, 0],
         [1, 1, 1, 1] ]
solveMaze(maze)

##
You are given an integer N. For a given N x N chessboard, find a way to place 'N' queens such that no queen can attack any other queen on the chessboard.
global N
N = int(input())
 
def printSolution(board):
    for i in range(N):
        for j in range(N):
            print(board[i][j], end = " ")
        print()


 
def isSafe(board, row, col):
    for i in range(col):
        if board[row][i] == 1:
            return False
 
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False
 
    for i, j in zip(range(row, N, 1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False
    return True
 
def solveNQUtil(board, col):
    if col >= N:
        return True
    for i in range(N):
         if isSafe(board, i, col):
            board[i][col] = 1
            if solveNQUtil(board, col + 1) == True:
                return True
            board[i][col] = 0
    return False
 
def solveNQ():
    board = [ [0, 0, 0, 0, 0, 0 ,0, 0],
              [0, 0, 0, 0, 0, 0 ,0, 0],
              [0, 0, 0, 0, 0, 0 ,0, 0],
              [0, 0, 0, 0, 0, 0 ,0, 0],
              [0, 0, 0, 0, 0, 0 ,0, 0],
              [0, 0, 0, 0, 0, 0 ,0, 0],
              [0, 0, 0, 0, 0, 0 ,0, 0],
              [0, 0, 0, 0, 0, 0 ,0, 0] ]
    if solveNQUtil(board, 0) == False:
        print ("Solution does not exist")
        return False
    printSolution(board)
    return True
    
solveNQ()

##
We are given a list of n numbers and a number x, the task is to write a python program to find out all possible subsets of the list such that their sum is x.
# Write your code here

from itertools import combinations
def subsetSum(n, arr, x):
    for i in range(n):
        for subset in combinations(arr,i):
            if sum(subset)==x:
                print(list(subset))




n=int(input())
arr=[]
for i in range(0,n):
    a=int(input())
    arr.append(a)
x = int(input())

subsetSum(n, arr, x)

##
Given a set of positive integers, and a value sum, determine that the sum of the subset of a given set is equal to the given sum.
def SubsetSum(a,i,sum,target,n):
    if i==n:
        return sum==target
    if sum>target:
        return False
    if sum==target:
        return True
    return SubsetSum(a,i+1,sum,target,n) or SubsetSum(a,i+1,sum+a[i],target,n)

# Write your code here








a=[]
size=int(input())
for i in range(size):
    x=int(input())
    a.append(x)

target=int(input())
n=len(a)
if(SubsetSum(a,0,0,target,n)==True):
    for i in range(size):
        print(a[i])
    print("True,subset found")
else:
    for i in range(size):
        print(a[i])
    print("False,subset not found")

##
Given an array arr[] of length N and an integer X, the task is to find the number of subsets with a sum equal to X.
def subsetSum(arr, n, i,sum, count):
    if (n==i):
        if (sum==0):
            count+=1
        return count
    count=subsetSum(arr, n, i+1,sum, count)
    count=subsetSum(arr, n, i+1,sum-arr[i], count)
    return count



arr=[]
size=int(input())
for j in range(size):
    value=int(input())
    arr.append(value)
sum = int(input())
n = len(arr)
 
print(subsetSum(arr, n, 0, sum, 0))

##
Given a set of positive integers, and a value sum, determine that the sum of the subset of a given set is equal to the given sum.
def SubsetSum(a,i,sum,target,n):
    if i==n:
        return sum==target
    if sum==target:
        return False
    if sum>target:
        return True
    return SubsetSum(a,i+1,sum,target,n) or SubsetSum(a,i+1,sum+a[i],target,n) 
        








a=[]
size=int(input())
for i in range(size):
    x=int(input())
    a.append(x)

target=int(input())
n=len(a)
if(SubsetSum(a,0,0,target,n)==True):
    for i in range(size):
        print(a[i])
    print("True,subset found")
else:
    for i in range(size):
        print(a[i])
    print("False,subset not found")

##
Given an undirected graph and a number m, determine if the graph can be coloured with at most m colours such that no two adjacent vertices of the graph are colored with the same color. Here coloring of a graph means the assignment of colors to all vertices.
class Graph():
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0 for column in range(vertices)]for row in range(vertices)]
 
    def isSafe(self, v, colour, c):
        for i in range(self.V):
            if self.graph[v][i] == 1 and colour[i] == c:
                return False
        return True

    def graphColourUtil(self, m, colour, v):
        if v == self.V:
            return True
        for c in range(1, m + 1):
            if self.isSafe(v, colour, c) == True:
                colour[v] = c
                if self.graphColourUtil(m, colour, v + 1) == True:
                    return True
                colour[v] = 0

    def graphColouring(self, m):
        colour = [0] * self.V
        if self.graphColourUtil(m, colour, 0) == None:
            return False
        print ("Solution exist and Following are the assigned colours:")
        for c in colour:
            print (c,end=' ')
        return True

##
SUBSET SUM PROBLEM
def subsetSum(arr, n, i,sum, count):
    if (n==i):
        if (sum==0):
            count+=1
        return count
    count=subsetSum(arr, n, i+1,sum, count)
    count=subsetSum(arr, n, i+1,sum-arr[i], count)
    return count



arr=[]
size=int(input())
for j in range(size):
    value=int(input())
    arr.append(value)
sum = int(input())
n = len(arr)
 
print(subsetSum(arr, n, 0, sum, 0))
##
Write a python program to implement knight tour problem using warnsdorff's algorithm
KNIGHT_MOVES = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]
class KnightTour:
    def __init__(self, board_size):
        self.board_size = board_size  
        self.board = []
        for i in range(board_size[0]):
            temp = []
            for j in range(board_size[1]):
                temp.append(0)
            self.board.append(temp) 
        self.move = 1

    def print_board(self):
        print('board:')
        for i in range(self.board_size[0]):
            print(self.board[i])

    def warnsdroff(self, start_pos, GUI=False):

        x_pos,  y_pos = start_pos
        self.board[x_pos][y_pos] = self.move
        if not GUI:
            while self.move <= self.board_size[0] * self.board_size[1]:
                self.move += 1
                next_pos = self.find_next_pos((x_pos, y_pos))
                if next_pos:
                    x_pos, y_pos = next_pos
                    self.board[x_pos][y_pos] = self.move
                else:
                    self.print_board()
                    return self.board
        else:
            if self.move <= self.board_size[0] * self.board_size[1]:
                self.move += 1
                next_pos = self.find_next_pos((x_pos, y_pos))
                return next_pos

    def find_next_pos(self, current_pos):
        empty_neighbours = self.find_neighbours(current_pos)
        if len(empty_neighbours) == 0:
            return
        least_neighbour = 8
        least_neighbour_pos = ()
        for neighbour in empty_neighbours:
            neighbours_of_neighbour = self.find_neighbours(pos=neighbour)
            if len(neighbours_of_neighbour) <= least_neighbour:
                least_neighbour = len(neighbours_of_neighbour)
                least_neighbour_pos = neighbour
        return least_neighbour_pos

    def find_neighbours(self, pos):
        neighbours = []
        for dx, dy in KNIGHT_MOVES:
            x = pos[0] + dx
            y = pos[1] + dy
            if 0 <= x < self.board_size[0] and 0 <= y < self.board_size[1] and self.board[x][y] == 0:
                neighbours.append((x, y))
        return neighbours

d1=int(input())
d2=int(input())
x=int(input())
y=int(input())
a = KnightTour((d1,d2))
a.warnsdroff((x,y))
##
Write a python program to implement knight tour problem
import sys
class KnightsTour:
    def __init__(self, width, height):
        self.w = width
        self.h = height
        self.board = []
        self.generate_board()

    def generate_board(self):
        for i in range(self.h):
            self.board.append([0]*self.w)

    def print_board(self):
        
        for elem in self.board:
            print (elem)
       
    def generate_legal_moves(self, cur_pos):
        possible_pos = []
        move_offsets = [(1, 2), (1, -2), (-1, 2), (-1, -2),
                        (2, 1), (2, -1), (-2, 1), (-2, -1)]
        for move in move_offsets:
            new_x = cur_pos[0] + move[0]
            new_y = cur_pos[1] + move[1]

            if (new_x >= self.h):
                continue
            elif (new_x < 0):
                continue
            elif (new_y >= self.w):
                continue
            elif (new_y < 0):
                continue
            else:
                possible_pos.append((new_x, new_y))

        return possible_pos

    def sort_lonely_neighbors(self, to_visit):
        neighbor_list = self.generate_legal_moves(to_visit)
        empty_neighbours = []

        for neighbor in neighbor_list:
            np_value = self.board[neighbor[0]][neighbor[1]]
            if np_value == 0:
                empty_neighbours.append(neighbor)

        scores = []
        for empty in empty_neighbours:
            score = [empty, 0]
            moves = self.generate_legal_moves(empty)
            for m in moves:
                if self.board[m[0]][m[1]] == 0:
                    score[1] += 1
            scores.append(score)

        scores_sort = sorted(scores, key = lambda s: s[1])
        sorted_neighbours = [s[0] for s in scores_sort]
        return sorted_neighbours

    def tour(self, n, path, to_visit):
        self.board[to_visit[0]][to_visit[1]] = n
        path.append(to_visit) 
        if n == self.w * self.h: 
            self.print_board()
            print (path)
            print ("Done!")
            sys.exit(1)

        else:
            sorted_neighbours = self.sort_lonely_neighbors(to_visit)
            for neighbor in sorted_neighbours:
                self.tour(n+1, path, neighbor)
            self.board[to_visit[0]][to_visit[1]] = 0
            try:
                path.pop()
            except IndexError:
                print ("No path found")
                sys.exit(1)

if __name__ == '__main__':
    x=int(input())
    y=int(input())
    kt = KnightsTour(x,y)
    kt.tour(1, [], (0,0))
    kt.print_board()
##
Write a python program to find minimum steps to reach to specific cell in minimum moves by knight.
class cell:
     
    def __init__(self, x = 0, y = 0, dist = 0):
        self.x = x
        self.y = y
        self.dist = dist

def isInside(x, y, N):
    if (x >= 1 and x <= N and
        y >= 1 and y <= N):
        return True
    return False
def minStepToReachTarget(knightpos,
                         targetpos, N):

    dx = [2, 2, -2, -2, 1, 1, -1, -1]
    dy = [1, -1, 1, -1, 2, -2, 2, -2]
    queue = []
    queue.append(cell(knightpos[0], knightpos[1], 0))
    visited = [[False for i in range(N + 1)] for j in range(N + 1)]
    visited[knightpos[0]][knightpos[1]] = True
    while(len(queue) > 0):
        t = queue[0]
        queue.pop(0)
        if(t.x == targetpos[0] and
           t.y == targetpos[1]):
            return t.dist
        for i in range(8):
            x = t.x + dx[i]
            y = t.y + dy[i]
            if(isInside(x, y, N) and not visited[x][y]):
                visited[x][y] = True
                queue.append(cell(x, y, t.dist + 1))

if __name__=='__main__':
    N = 30
    knightpos = [1, 1]
    targetpos = [30, 30]
    print(minStepToReachTarget(knightpos,
                               targetpos, N))
##
Write a python program to implement knight tour problem using backtracking
BOARD_SIZE = int(input())
board = [[0 for i in range(BOARD_SIZE)] for j in range(BOARD_SIZE)]    
STEPS = [[-1, 2], [1, 2], [-2, 1], [2, 1], [1, -2], [-1, -2], [2, -1], [-2, -1]]
 
 
def solve_knights_tour(x, y, step_count):

    if step_count > BOARD_SIZE * BOARD_SIZE:
        return True
    for step in STEPS:
        next_x = x + step[0]
        next_y = y + step[1]
        if is_safe(next_x, next_y):
            board[next_x][next_y] = step_count
            if solve_knights_tour(next_x, next_y, step_count + 1):
                return True
            board[next_x][next_y] = 0       
    return False

def is_safe(x, y):
    return 0 <= x < BOARD_SIZE and 0 <= y < BOARD_SIZE and board[x][y] == 0
 
 
def print_solution():
    for row in board:
        for col in row:
            print("0" + str(col) if col < 10 else col, end=" ")
        print()
 
 
board[0][0] = 1     
 
if solve_knights_tour(0, 0, 2):
    print("Found a solution")
    print_solution()
else:
    print("Could not find a solution")
##
Write a python program to Count paths with exactly 'k' coins.
R = 3
C = 3
MAX_K = 1000
def pathCountDPRecDP(mat, m, n, k):
    if m < 0 or n < 0 or k < 0:
        return 0
    elif m == 0 and n == 0:
        return k == mat[m][n]
    if (dp[m][n][k] != -1):
        return dp[m][n][k]
    dp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) + pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]))
    return dp[m][n][k]
def pathCountDP(mat, k):
    return pathCountDPRecDP(mat, R - 1, C - 1, k)
k = 12
dp = [[ [-1 for col in range(MAX_K)]
            for col in range(C)]
            for row in range(R)]
mat = [[1, 2, 3],
       [4, 6, 5],
       [3, 2, 1]]
print(pathCountDP(mat, k))
##
Create a python program to implement Hamiltonian circuit problem using Backtracking.
class Graph():
    def __init__(self, vertices):
        self.graph = [[0 for column in range(vertices)]
                            for row in range(vertices)]
        self.V = vertices
    def isSafe(self, v, pos, path):
        if self.graph[ path[pos-1] ][v] == 0:
            return False
        for vertex in path:
            if vertex == v:
                return False
 
        return True
    def hamCycleUtil(self, path, pos):

        if pos == self.V:
            if self.graph[ path[pos-1] ][ path[0] ] == 1:
                return True
            else:
                return False
        for v in range(1,self.V):
            if self.isSafe(v, pos, path) == True:
                path[pos] = v
                if self.hamCycleUtil(path, pos+1) == True:
                    return True
                path[pos] = -1
        return False
 
    def hamCycle(self):
        path = [-1] * self.V
        path[0] = 0
 
        if self.hamCycleUtil(path,1) == False:
            print ("Solution does not exist\n")
            return False
 
        self.printSolution(path)
        return True
 
    def printSolution(self, path):
        print ("Solution Exists: Following",
                 "is one Hamiltonian Cycle")
        for vertex in path:
            print (vertex, end = " ")
        print (path[0], "\n")
g1 = Graph(5)
g1.graph = [ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1],
            [0, 1, 0, 0, 1,],[1, 1, 0, 0, 1],
            [0, 1, 1, 1, 0], ]
g1.hamCycle();
##
Write a python program to check whether Hamiltonian path exits in the given graph.
def Hamiltonian_path(adj, N):

    dp = [[False for i in range(1 << N)] for j in range(N)]
    for i in range(N):
        dp[i][1 << i] = True
    for i in range(1 << N):
        for j in range(N):
            if ((i & (1 << j)) != 0):
 
                for k in range(N):
                    if ((i & (1 << k)) != 0 and
                             adj[k][j] == 1 and
                                     j != k and
                          dp[k][i ^ (1 << j)]):
                        dp[j][i] = True
                        break
    for i in range(N):
        if (dp[i][(1 << N) - 1]):
            return True
    return False
    
adj = [ [ 0, 1, 1, 1, 0 ] ,
        [ 1, 0, 1, 0, 1 ],
        [ 1, 1, 0, 1, 1 ],
        [ 1, 0, 1, 0, 0 ] ]
 
N = len(adj)
 
if (Hamiltonian_path(adj, N)):
    print("YES")
else:
    print("NO")
##
Create a python program to find the Hamiltonian path using Depth First Search for traversing the graph .
class Hamiltonian:
    def __init__(self, start):
        self.start = start
        self.cycle = []
        self.hasCycle = False
        
    def findCycle(self):
        self.cycle.append(self.start)
        self.solve(self.start)
        
    def solve(self, vertex):
        if vertex == self.start and len(self.cycle) == N+1:
            self.hasCycle = True
            self.displayCycle()
            return
        for i in range(len(vertices)):
            if adjacencyM[vertex][i] == 1 and visited[i] == 0:
                nbr = i
                visited[nbr] = 1
                self.cycle.append(nbr)
                self.solve(nbr)
                visited[nbr] = 0
                self.cycle.pop()
        
    def displayCycle(self):
        names = []
        for v in self.cycle:
            names.append(vertices[v])
        print(names)
      


if __name__ == '__main__':
    vertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
    adjacencyM = [[0, 1, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 0],
                [0, 1, 0, 1, 0, 0, 0, 1],
                [0, 0, 1, 0, 1, 0, 1, 0],
                [0, 0, 0, 1, 0, 1, 0, 0],
                [0, 0, 0, 0, 1, 0, 1, 0],
                [0, 0, 0, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 1, 0]]
    visited = [0 for x in range(len(vertices))]
    N = 8
    hamiltonian = Hamiltonian(0)
    hamiltonian.findCycle()
    if not hamiltonian.hasCycle:
        print("No Hamiltonian Cycle")
##
Create a python program to find the solution of sudoku puzzle using Backtracking.
board = [
    [0, 0, 0, 8, 0, 0, 4, 0, 3],
    [2, 0, 0, 0, 0, 4, 8, 9, 0],
    [0, 9, 0, 0, 0, 0, 0, 0, 2],
    [0, 0, 0, 0, 2, 9, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 7, 0, 6, 5, 0, 0, 0, 0],
    [9, 0, 0, 0, 0, 0, 0, 8, 0],
    [0, 6, 2, 7, 0, 0, 0, 0, 1],
    [4, 0, 3, 0, 0, 6, 0, 0, 0]
]

def printBoard(board):
    for i in range(0, 9):
        for j in range(0, 9):
            print(board[i][j], end=" ")
        print()

def isPossible(board, row, col, val):
    for j in range(0, 9):
        if board[row][j] == val:
            return False

    for i in range(0, 9):
        if board[i][col] == val:
            return False

    startRow = (row // 3) * 3
    startCol = (col // 3) * 3
    for i in range(0, 3):
        for j in range(0, 3):
            if board[startRow+i][startCol+j] == val:
                return False
    return True

def solve():

    for i in range(0, 9):
        for j in range(0, 9):
            if board[i][j] == 0:
                for val in range(1, 10):
                    if isPossible(board, i, j, val):
                        board[i][j] = val
                        solve()
                        board[i][j] = 0
                return
    printBoard(board)
solve()
##
Write a python program to implement sudoku solver using backtracking to find the the safe position in the grid.
SIZE = 9
matrix = [
    [6,5,0,8,7,3,0,9,0],
    [0,0,3,2,5,0,0,0,8],
    [9,8,0,1,0,4,3,5,7],
    [1,0,5,0,0,0,0,0,0],
    [4,0,0,0,0,0,0,0,2],
    [0,0,0,0,0,0,5,0,3],
    [5,7,8,3,0,1,0,2,6],
    [2,0,0,0,4,8,9,0,0],
    [0,9,0,6,2,5,0,8,1]]
def print_sudoku():
    for i in matrix:
        print (i)
def number_unassigned(row, col):
    num_unassign = 0
    for i in range(0,SIZE):
        for j in range (0,SIZE):
            if matrix[i][j] == 0:
                row = i
                col = j
                num_unassign = 1
                a = [row, col, num_unassign]
                return a
    a = [-1, -1, num_unassign]
    return a
def is_safe(n, r, c):
    for i in range(0,SIZE):
        if matrix[r][i] == n:
            return False
    for i in range(0,SIZE):
        if matrix[i][c] == n:
            return False
    row_start = (r//3)*3
    col_start = (c//3)*3;
    for i in range(row_start,row_start+3):
        for j in range(col_start,col_start+3):
            if matrix[i][j]==n:
                return False
    return True
    
def solve_sudoku():
    row = 0
    col = 0
    a = number_unassigned(row, col)
    if a[2] == 0:
        return True
    row = a[0]
    col = a[1]
    for i in range(1,10):
        if is_safe(i, row, col):
            matrix[row][col] = i
            if solve_sudoku():
                return True
            matrix[row][col]=0
    return False

if solve_sudoku():
    print_sudoku()
else:
    print("No solution")
##
Write a python program to implement sudoku solver using Brute force method
def draw(puzzle):
    for r in range(len(puzzle)):
        if r == 0 or r == 3 or r == 6:
            print("+-------+-------+-------+")
        for c in range(len(puzzle[r])):
            if c == 0 or c == 3 or c ==6:
                print("| ", end = "")
            if puzzle[r][c] != 0:
                print(puzzle[r][c], end = " ")
            else:
                print(end = "  ")
            if c == 8:
                print("|")
    print("+-------+-------+-------+")
    
def str_to_puzzle(s):
    puzzleSolution = []
    for i in range(len(s)):  
        if i % 9 == 0:
            temp = []
            for j in s[i:i+9]:
                temp.append(int(j))
            puzzleSolution.append(temp)
    return puzzleSolution
    
def same_row(i,j):
    if i//9 == j//9:
        return True
    return False

def same_col(i,j):
    if i%9 == j%9:
        return True
    return False

def same_block(i,j):
    if ((i//9)//3 == (j//9)//3) & ((i%9)//3 == (j%9)//3):
        return True
    return False

def sudoku_brute_force(s):

    i = s.find('0')

    cannotuse = {s[j] for j in range(len(s)) if same_row(i, j) | same_col(i, j) | same_block(i, j)}
    every_possible_values = {str(i) for i in range(10)} - cannotuse

    for val in every_possible_values:
        s = s[0:i] + val + s[i+1: ]
        sudoku_brute_force(s)
        if s.find('0') == -1:
            draw(str_to_puzzle(s))

puzzleToSolve =  [[5, 3, 0, 0, 7, 0, 0, 0, 0],
                  [6, 0, 0, 1, 9, 5, 0, 0, 0],
                  [0, 9, 8, 0, 0, 0, 0, 6, 0],
                  [8, 0, 0, 0, 6, 0, 0, 0, 3],
                  [4, 0, 0, 8, 0, 3, 0, 0, 1],
                  [7, 0, 0, 0, 2, 0, 0, 0, 6],
                  [0, 6, 0, 0, 0, 0, 2, 8, 0],
                  [0, 0, 0, 4, 1, 9, 0, 0, 5],
                  [0, 0, 0, 0, 8, 0, 0, 7, 9]]

s = ''.join(map(str,[''.join(map(str, i)) for i in puzzleToSolve]))

print("Sudoku Problem")
draw(puzzleToSolve)
print("\nSudoku Solution")
sudoku_brute_force(s)
##
Write a python program to implement  KMP (Knuth Morris Pratt).
def KMPSearch(pat, txt):

    M = len(pat)
    N = len(txt)
    lps = [0]*M
    j = 0
    computeLPSArray(pat, M, lps)
    i = 0
    while (N - i) >= (M - j):
        if pat[j] == txt[i]:
            i += 1
            j += 1
        if j == M:
            print ("Found pattern at index " + str(i-j))
            j = lps[j-1]
        elif i < N and pat[j] != txt[i]:
            if j != 0:
                j = lps[j-1]
            else:
                i += 1

def computeLPSArray(pat, M, lps):
    len = 0 
 
    lps[0] 
    i = 1
    while i < M:
        if pat[i]== pat[len]:
            len += 1
            lps[i] = len
            i += 1
        else:
            if len != 0:
                len = lps[len-1]
            else:
                lps[i] = 0
                i += 1
txt = input()                      
pat = input()
KMPSearch(pat, txt)
##
Write a Python program for Bad Character Heuristic of Boyer Moore String Matching Algorithm
NO_OF_CHARS = 256
def badCharHeuristic(string, size):

    badChar = [-1]*NO_OF_CHARS
    for i in range(size):
        badChar[ord(string[i])] = i;
    return badChar

def search(txt, pat):
    m = len(pat)
    n = len(txt)
    badChar = badCharHeuristic(pat, m)
    s = 0
    while(s <= n-m):
        j = m-1
        while j>=0 and pat[j] == txt[s+j]:
            j -= 1
        if j<0:
            print("Pattern occur at shift = {}".format(s))
            s += (m-badChar[ord(txt[s+m])] if s+m<n else 1)
        else:
            s += max(1, j-badChar[ord(txt[s+j])])
def main():
    txt = input()                      
    pat = input()                     
    search(txt, pat)
 
if __name__ == '__main__':
    main()
##
Write a python program to implement  Boyer Moore Algorithm with Good Suffix heuristic to find pattern in given text string.
def preprocess_strong_suffix(shift, bpos, pat, m):

    i = m
    j = m + 1
    bpos[i] = j
    while i > 0:
        while j <= m and pat[i - 1] != pat[j - 1]:
            if shift[j] == 0:
                shift[j] = j - i
            j = bpos[j]
        i -= 1
        j -= 1
        bpos[i] = j

def preprocess_case2(shift, bpos, pat, m):
    j = bpos[0]
    for i in range(m + 1):
        if shift[i] == 0:
            shift[i] = j
        if i == j:
            j = bpos[j]
def search(text, pat):
    s = 0
    m = len(pat)
    n = len(text)
    bpos = [0] * (m + 1)
    shift = [0] * (m + 1)
    preprocess_strong_suffix(shift, bpos, pat, m)
    preprocess_case2(shift, bpos, pat, m)
    while s <= n - m:
        j = m - 1
        while j >= 0 and pat[j] == text[s + j]:
            j -= 1
        if j < 0:
            print("pattern occurs at shift = %d" % s)
            s += shift[0]
        else:
            s += shift[j + 1]
if __name__ == "__main__":
    text =input()  
    pat =input() 
    search(text, pat)
##
Write a python program to implement pattern matching on the given string using Brute Force algorithm.
def BF(s1,s2):

    i = 0
    j = 0
    while(i < len(s1) and j < len(s2)):
        if(s1[i] ==  s2[j]):
            i += 1
            j += 1
        else:
            i = i - j + 1
            j = 0
    if(j >= len(s2)):
        return i - len(s2)
    else:
        return 0

if __name__ == "__main__":
    a1=input() 
    a2=input() 
    b=BF(a1,a2)
    print(b)
##
To Write a Python Program to find longest common subsequence using Dynamic Programming
def lcs(str1, str2):
    m, n = len(str1), len(str2)
    table = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                table[i][j] = 1 + table[i-1][j-1]
            else:
                table[i][j] = max(table[i-1][j], table[i][j-1])
    lcs = ""
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs = str1[i-1] + lcs
            i -= 1
            j -= 1
        elif table[i-1][j] > table[i][j-1]:
            i -= 1
        else:
            j -= 1
    return lcs
str1=input()
str2=input()
print(lcs(str1,str2))
##
Write a Python Program to find longest common subsequence using Dynamic Programming
def lcs(str1, str2):
    m, n = len(str1), len(str2)
    table = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                table[i][j] = 1 + table[i-1][j-1]
            else:
                table[i][j] = max(table[i-1][j], table[i][j-1])
    lcs = ""
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs = str1[i-1] + lcs
            i -= 1
            j -= 1
        elif table[i-1][j] > table[i][j-1]:
            i -= 1
        else:
            j -= 1
            
    print("Length of LCS is :",len(lcs))
str1=input()
str2=input()
lcs(str1,str2)
##
Create a python program to find the length of longest common subsequence using naive recursive method
def lcs(str1, str2):
    m, n = len(str1), len(str2)
    table = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                table[i][j] = 1 + table[i-1][j-1]
            else:
                table[i][j] = max(table[i-1][j], table[i][j-1])
    lcs = ""
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs = str1[i-1] + lcs
            i -= 1
            j -= 1
        elif table[i-1][j] > table[i][j-1]:
            i -= 1
        else:
            j -= 1
    return lcs
str1=input()
str2=input()
print("Length of LCS is ",len(lcs(str1,str2)))

##
Create a python program to find the longest common subsequence using Memoization Implementation.
def lcs(str1, str2):
    m, n = len(str1), len(str2)
    table = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                table[i][j] = 1 + table[i-1][j-1]
            else:
                table[i][j] = max(table[i-1][j], table[i][j-1])
    lcs = ""
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs = str1[i-1] + lcs
            i -= 1
            j -= 1
        elif table[i-1][j] > table[i][j-1]:
            i -= 1
        else:
            j -= 1
    return lcs
str1=input()
str2=input()
print("Length of LCS is",len(lcs(str1,str2)))

##
The longest common substring problem is the problem of finding the longest string (or strings) that is a substring (or are substrings) of two strings.
def lcs(str1, str2):
    m, n = len(str1), len(str2)
    table = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                table[i][j] = 1 + table[i-1][j-1]
            else:
                table[i][j] = max(table[i-1][j], table[i][j-1])
    lcs = ""
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs = str1[i-1] + lcs
            i -= 1
            j -= 1
        elif table[i-1][j] > table[i][j-1]:
            i -= 1
        else:
            j -= 1
    return lcs
str1=input()
str2=input()
print("The longest common substring is",(lcs(str1,str2)))

##
Given two strings ‘X’ and ‘Y’, find the length of the longest common substring. 
def lcs(str1, str2):
    m, n = len(str1), len(str2)
    table = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                table[i][j] = 1 + table[i-1][j-1]
            else:
                table[i][j] = max(table[i-1][j], table[i][j-1])
    lcs = ""
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs = str1[i-1] + lcs
            i -= 1
            j -= 1
        elif table[i-1][j] > table[i][j-1]:
            i -= 1
        else:
            j -= 1
    return lcs
str1=input()
str2=input()
print("Length of Longest Common Substring is",len(lcs(str1,str2)))

##
Create a Python program to find longest common substring or subword (LCW) of two strings using dynamic programming with bottom-up approach.
def lcw(u, v):
    m, n = len(u), len(v)
    table = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if u[i-1] == v[j-1]:
                table[i][j] = 1 + table[i-1][j-1]
            else:
                table[i][j] = max(table[i-1][j], table[i][j-1])
    lcw = ""
    i, j = m, n
    while i > 0 and j > 0:
        if u[i-1] == v[j-1]:
            lcw = u[i-1] + lcw
            i -= 1
            j -= 1
        elif table[i][j] >= table[i][j]:
            i -= 1
        else:
            j -= 1
    return lcw
u=input()
v=input()
print("Longest Common Subword:",lcw(u,v))

##
Create a  Python program to find longest common substring or subword (LCW) of two strings using dynamic programming with top-down approach or memoization.
def lcw(u, v):
    m, n = len(u), len(v)
    table = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if u[i-1] == v[j-1]:
                table[i][j] = 1 + table[i-1][j-1]
            else:
                table[i][j] = max(table[i-1][j], table[i][j-1])
    lcw = ""
    i, j = m, n
    while i > 0 and j > 0:
        if u[i-1] == v[j-1]:
            lcw = u[i-1] + lcw
            i -= 1
            j -= 1
        elif table[i][j] >= table[i][j]:
            i -= 1
        else:
            j -= 1
    return lcw
u=input()
v=input()
print("Longest Common Subword:",lcw(u,v))

##
Given a sequence, find the length of the longest palindromic subsequence in it.
dp = [[-1 for i in range(1001)]for j in range(1001)]
def lps(s1, s2, n1, n2):
    if (n1 == 0 or n2 == 0):
        return 0
    if (dp[n1][n2] != -1):
        return dp[n1][n2]
    if (s1[n1 - 1] == s2[n2 - 1]):
        dp[n1][n2] = 1 + lps(s1, s2, n1 - 1, n2 - 1)
        return dp[n1][n2]
    else:
        dp[n1][n2] = max(lps(s1, s2, n1 - 1, n2), lps(s1, s2, n1, n2 - 1))
        return dp[n1][n2]
seq = input()
n = len(seq)
s2 = seq
s2 = s2[::-1]
print("The length of the LPS is",lps(s2, seq, n, n))

##
Given a string s, return the longest palindromic substring in s.
class Solution(object):
   def longestPalindrome(self, s):
      ###########  Add your code here #############
      dp = [[False for i in range(len(s))] for i in range(len(s))]
      for i in range(len(s)):
         dp[i][i] = True
      max_length = 1
      start = 0
      for l in range(2,len(s)+1):
         for i in range(len(s)-l+1):
            end = i+l
            if l==2:
               if s[i] == s[end-1]:
                  dp[i][end-1]=True
                  max_length = l
                  start = i
            else:
               if s[i] == s[end-1] and dp[i+1][end-2]:
                  dp[i][end-1]=True
                  max_length = l
                  start = i
      return s[start:start+max_length]
ob1 = Solution()
str1=input()
print(ob1.longestPalindrome(str1))

##
Create a python program to find the longest palindromic substring using Brute force method in a given string.
def printSubStr(str, low, high):
	for i in range(low, high + 1):
		print(str[i], end = "")
def longestPalindrome(str):
	n = len(str)
	maxLength = 1
	start = 0
	for i in range(n):
		for j in range(i, n):
			flag = 1
			for k in range(0, ((j - i) // 2) + 1):
				if (str[i + k] != str[j - k]):
					flag = 0
			if (flag != 0 and (j - i + 1) > maxLength):
				start = i
				maxLength = j - i + 1
	printSubStr(str, start, start + maxLength - 1)
	
str = input()
longestPalindrome(str)

##
Create a python program to find the longest palindromic substring using optimal algorithm Expand around center.
def printSubStr(s, low, high):
	for i in range(low, high + 1):
		print(s[i], end = "")
def findLongestPalindromicSubstring(s):
	n = len(s)
	maxLength = 1
	start = 0
	for i in range(n):
		for j in range(i, n):
			flag = 1
			for k in range(0, ((j - i) // 2) + 1):
				if (s[i + k] != s[j - k]):
					flag = 0
			if (flag != 0 and (j - i + 1) > maxLength):
				start = i
				maxLength = j - i + 1
	printSubStr(s, start, start + maxLength - 1)
	
s = input()

##
Create a Naive recursive python program to find the minimum number of operations to convert str1 to str2
def LD(s, t):
    if s == "":
        return len(t)
    if t == "":
        return len(s)
    if s[-1] == t[-1]:
        cost = 0
    else:
        cost = 1
    res = min([LD(s[:-1], t)+1, LD(s, t[:-1])+1, LD(s[:-1], t[:-1]) + cost])
    return res
str1=input()
str2=input()
print('Edit Distance',LD(str1,str2))

##
Create a python program to find the Edit distance between two strings using dynamic programming.
def LD(s, t):
    if s == "":
        return len(t)
    if t == "":
        return len(s)
    if s[-1] == t[-1]:
        cost = 0
    else:
        cost = 1
    res = min([LD(s[:-1], t)+1, LD(s, t[:-1])+1, LD(s[:-1], t[:-1]) + cost])
    return res
str1=input()
str2=input()
print("No. of Operations required :",LD(str1,str2))

##
Create a python program to compute the edit distance between two given strings using iterative method.
def LD(s, t):
    if s == "":
        return len(t)
    if t == "":
        return len(s)
    if s[-1] == t[-1]:
        cost = 0
    else:
        cost = 1
    res = min([LD(s[:-1], t)+1, LD(s, t[:-1])+1, LD(s[:-1], t[:-1]) + cost])
    return res
str1=input()
str2=input()
print(LD(str1,str2))
Write a python program to Implement Minimum cost path using Dynamic Programming.
R = int(input())
C = int(input())
def minCost(cost, m, n):
    tc = [[0 for x in range(C)] for x in range(R)]
    tc[0][0] = cost[0][0]
    for i in range(1, m+1):
        tc[i][0] = tc[i-1][0] + cost[i][0]
    for j in range(1, n+1):
        tc[0][j] = tc[0][j-1] + cost[0][j]
    for i in range(1, m+1):
        for j in range(1, n+1):
            tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]
 
    return tc[m][n]
 
cost = [[1, 2, 3],
        [4, 8, 2],
        [1, 5, 3]]
print(minCost(cost, R-1, C-1))

##
Write a Python program using A Naive recursive implementation of Minimum Cost Path Problem.
R = int(input())
C = int(input())
def minCost(cost, m, n):
    tc = [[0 for x in range(C)] for x in range(R)]
    tc[0][0] = cost[0][0]
    for i in range(1, m+1):
        tc[i][0] = tc[i-1][0] + cost[i][0]
    for j in range(1, n+1):
        tc[0][j] = tc[0][j-1] + cost[0][j]
    for i in range(1, m+1):
        for j in range(1, n+1):
            tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]
 
    return tc[m][n]
 
cost = [[1, 2, 3],
        [4, 8, 2],
        [1, 5, 3]]
print(minCost(cost, R-1, C-1))

##
Write a Python program to Implement Minimum cost path in a Directed Graph
minSum = 1000000000
def getMinPathSum(graph, visited, necessary,
                  src, dest, currSum):
    ################# Add your Code here ################
    #Start here
    global minSum
    if (src == dest):
        flag = True;
        for i in necessary:
            if (not visited[i]):
                flag = False;
                break;
        if (flag):
            minSum = min(minSum, currSum);
        return;
     
    else:
        visited[src] = True;
        for node in graph[src]:
            if not visited[node[0]]:
                visited[node[0]] = True;
                getMinPathSum(graph, visited,
                              necessary, node[0],
                              dest, currSum + node[1]);
                visited[node[0]] = False;
        visited[src] = False;
    #End here
    
if __name__=='__main__':
    graph=dict()
    graph[0] = [ [ 1, 2 ], [ 2, 3 ], [ 3, 2 ] ];
    graph[1] = [ [ 4, 4 ], [ 0, 1 ] ];
    graph[2] = [ [ 4, 5 ], [ 5, 6 ] ];
    graph[3] = [ [ 5, 7 ], [ 0, 1 ] ];
    graph[4] = [ [ 6, 4 ] ];
    graph[5] = [ [ 6, 2 ] ];
    graph[6] = [ [ 7, 11 ] ];
    n = 7;
    source = 0;
    dest = 6;
    visited=[ False for i in range(n + 1)]
    necessary = [ 2, 4 ];
    getMinPathSum(graph, visited, necessary,
                  source, dest, 0);
  
    # If no path is found
    if (minSum == 1000000000):
        print(-1)
    else:
        print(minSum)

##
Write a Python Program for printing Minimum Cost Simple Path between two given nodes in a directed and weighted graph
import sys
V = 5
INF = sys.maxsize
def minimumCostSimplePath(u, destination,
                          visited, graph):
########  Add your code here ##############
    #Start here
    if (u == destination):
        return 0
    visited[u] = 1
    ans = INF
    for i in range(V):
        if (graph[u][i] != INF and not visited[i]):
            curr = minimumCostSimplePath(i, destination,
                                         visited, graph)
            if (curr < INF):
                ans = min(ans, graph[u][i] + curr)
    visited[u] = 0
    return ans
    #End here

if __name__=="__main__":
    graph = [[INF for j in range(V)]
                  for i in range(V)]
    visited = [0 for i in range(V)]
    graph[0][1] = -1
    graph[0][3] = 1
    graph[1][2] = -2
    graph[2][0] = -3
    graph[3][2] = -1
    graph[4][3] = 2
    s = 0
    t = 2
    visited[s] = 1
    print(minimumCostSimplePath(s, t, visited, graph))


##
Create a Python Function to find the total number of distinct ways to get a change of 'target'  from an unlimited supply of coins in set 'S'.
def count(S, n, target):
    ###################  Add Your Code Here #################
    #Start here
    if target == 0:
        return 1
    if target < 0 or n < 0:
        return 0
    incl = count(S, n, target - S[n])
    excl = count(S, n - 1, target)
    return incl + excl
    #End here

if __name__ == '__main__':
    S = []#[1, 2, 3]
    n=int(input())
    target = int(input())
    for i in range(n):
        S.append(int(input()))
    print('The total number of ways to get the desired change is',
        count(S, len(S) - 1, target))

##
You are given an n x n grid representing a field of cherries, each cell is one of three possible integers.
class Solution:
    def cherryPickup(self, grid):
        n = len(grid)
        #############    Add your code here  ############### 
        #Start here
        dp = [[-1] * (n + 1) for _ in range(n + 1)]
        dp[1][1] = grid[0][0]
        for m in range(1, (n << 1) - 1):
            for i in range(min(m, n - 1), max(-1, m - n), -1):
                for p in range(i, max(-1, m - n), -1):
                    j, q = m - i, m - p
                    if grid[i][j] == -1 or grid[p][q] == -1:
                        dp[i + 1][p + 1] = -1
                    else:
                        dp[i + 1][p + 1] = max(dp[i + 1][p + 1], dp[i][p + 1], dp[i + 1][p], dp[i][p])
                        if dp[i + 1][p + 1] != -1: dp[i + 1][p + 1] += grid[i][j] + (grid[p][q] if i != p else 0)
        return max(0, dp[-1][-1])
        n,m=len(grid),len(grid[0])
        dp = [[[-1 for i in range(m)] for j1 in range(n)] for j2 in range(n)]
        #End here
        return f(0,0,m-1,dp)
obj=Solution()
grid=[[0,1,-1],[1,0,-1],[1,1,1]]        
print(obj.cherryPickup(grid))

##
Create a python function to compute the fewest number of coins that we need to make up the amount given.
class Solution(object):
    def coinChange(self, coins, amount):
        ####################      Add your Code Here ###########
        #End here
        if amount == 0 :
            return 0
        if min(coins) > amount:
            return -1
        dp = [-1 for i in range(0, amount + 1)]
        for i in coins:
            if i > len(dp) - 1:
                continue
            dp[i] = 1
            for j in range(i + 1, amount + 1):
                if dp[j - i] == -1:
                    continue
                elif dp[j] == -1:
                    dp[j] = dp[j - i] + 1
                else:
                    dp[j] = min(dp[j], dp[j - i] + 1)
        return dp[amount]
    #End here
      
ob1 = Solution()
n=int(input())
s=[]
amt=int(input())
for i in range(n):
    s.append(int(input()))
print(ob1.coinChange(s,amt))

##
Create a Dynamic Programming  python Implementation  of Coin Change Problem.
def count(S, m, n):
    table = [[0 for x in range(m)] for x in range(n+1)]
    for i in range(m):
        table[0][i] = 1
    for i in range(1, n+1):
        for j in range(m):
            # Count of solutions including S[j]
            #Start here
            x = table[i - S[j]][j] if i-S[j] >= 0 else 0
            # Count of solutions excluding S[j]
            y = table[i][j-1] if j >= 1 else 0
            # total count
            table[i][j] = x + y
    return table[n][m-1]
    #End here
arr = []      
m = int(input())
n = int(input())
for i in range(m):
    arr.append(int(input()))
print(count(arr, m, n))

##
Write a python program to find the maximum contiguous subarray.
def maxSubArraySum(a,size):
    #####################  Add your Code here #############
    #Start here
    max_so_far = a[0]
    max_ending_here = 0
    for i in range(0, size):
        max_ending_here = max_ending_here + a[i]
        if max_ending_here < 0:
            max_ending_here = 0
        elif (max_so_far < max_ending_here):
            max_so_far = max_ending_here
              
    return max_so_far
    #End here
n=int(input())  
a =[] #[-2, -3, 4, -1, -2, 1, 5, -3]
for i in range(n):
    a.append(int(input()))
print("Maximum contiguous sum is", maxSubArraySum(a,n))

##
Create a python Program to find the maximum contiguous  sub array using Dynamic Programming.
def maxSubArraySum(a,size):
    max_so_far =a[0]
    curr_max = a[0]
    for i in range(1,size):
        curr_max = max(a[i], curr_max + a[i])
        max_so_far = max(max_so_far,curr_max)
    return max_so_far
    
n=int(input())  
a =[] #[-2, -3, 4, -1, -2, 1, 5, -3]
for i in range(n):
    a.append(int(input()))
print("Maximum contiguous sum is", maxSubArraySum(a,n))

##
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
class Solution:
    def maxSubArray(self,A):
        ############ Add your Code here
        #Start here
        res=0
        mm= -10000
        for v in A:
            res+=v
            mm=max(mm,res)
            if res<0:
                res=0
        return mm
        #End here
A =[]                  
n=int(input())
for i in range(n):
    A.append(int(input()))
s=Solution()
print("The sum of contiguous sublist with the largest sum is",s.maxSubArray(A))

##
Write a python program to find the maximum contiguous subarray on the given float array using kadane's algorithm.
class Solution:
    #####################  Add your Code here #############
    def maxSubArray(self,A):
        res=0
        mm= -10000
        for v in A:
            res+=v
            mm=max(mm,res)
            if res<0:
                res=0
        return mm
A =[]                  
n=int(input())
for i in range(n):
    A.append(float(input()))
s=Solution()
print("The sum of contiguous sublist with the largest sum is {:.1f}".format(s.maxSubArray(A)))

##
Create a python program to find Minimum number of jumps to reach end  of the array using naive method(recursion)
def minJumps(arr, l, h):
    ###########   Add your code here ###########
    #Start here
    if (h == l):
        return 0
    if (arr[l] == 0):
        return float('inf')
    min = float('inf')
    for i in range(l + 1, h + 1):
        if (i < l + arr[l] + 1):
            jumps = minJumps(arr, i, h)
            if (jumps != float('inf') and
                       jumps + 1 < min):
                min = jumps + 1
    return min
    #End here
arr = []
n = int(input()) 
for i in range(n):
    arr.append(int(input()))
print('Minimum number of jumps to reach','end is', minJumps(arr, 0, n-1))

##
Create a python program to find the minimum number of jumps needed to reach end of the array using Dynamic Programming.
def minJumps(arr, n):
    ##########  Add your code here ##############
    #Start here
    jumps = [0 for i in range(n)]
    if (n == 0) or (arr[0] == 0):
        return float('inf')
    jumps[0] = 0
    for i in range(1, n):
        jumps[i] = float('inf')
        for j in range(i):
            if (i <= j + arr[j]) and (jumps[j] != float('inf')):
                jumps[i] = min(jumps[i], jumps[j] + 1)
                break
    return jumps[n-1]
    #End here
arr = []
n = int(input()) #len(arr)
for i in range(n):
    arr.append(int(input()))
print('Minimum number of jumps to reach','end is', minJumps(arr,n))

##
Print All Paths With Minimum Jumps
from queue import Queue
import sys
class Pair(object):
    idx = 0
    psf = ""
    jmps = 0
    def __init__(self, idx, psf, jmps):
         
        self.idx = idx
        self.psf = psf
        self.jmps = jmps
def minJumps(arr):
    #################  Add your Code here.
    #Start here
    MAX_VALUE = sys.maxsize
    dp = [MAX_VALUE for i in range(len(arr))]
    n = len(dp)
    dp[n - 1] = 0
    for i in range(n - 2, -1, -1):
        steps = arr[i]
        minimum = MAX_VALUE
        for j in range(1, steps + 1, 1):
            if i + j >= n:
                break
            if ((dp[i + j] != MAX_VALUE) and
                (dp[i + j] < minimum)):
                minimum = dp[i + j]
        if minimum != MAX_VALUE:
            dp[i] = minimum + 1
    return dp
    #End here
    
def possiblePath(arr, dp):
 
    queue = Queue(maxsize = 0)
    p1 = Pair(0, "0", dp[0])
    queue.put(p1)
 
    while queue.qsize() > 0:
        tmp = queue.get()
 
        if tmp.jmps == 0:
            print(tmp.psf)
            continue
 
        for step in range(1, arr[tmp.idx] + 1, 1):
            if ((tmp.idx + step < len(arr)) and
               (tmp.jmps - 1 == dp[tmp.idx + step])):
               
                # Storing the neighbours
                # of current index element
                p2 = Pair(tmp.idx + step, tmp.psf +
                           " -> " + str((tmp.idx + step)),
                         tmp.jmps - 1)
                          
                queue.put(p2)
def Solution(arr):
    dp = minJumps(arr)
    possiblePath(arr, dp)
    
if __name__ == "__main__":
     
    arr = []#[ 3, 3, 0, 2, 1,2, 4, 2, 0, 0 ]
    size = int(input())
    for i in range(size):
        arr.append(int(input()))
    Solution(arr)

##
Create a python program to find Minimum number of jumps to reach end  of the array using naive method(recursion) using float values
def minJumps(arr, l, h):
    ###########   Add your code here ###########
    #Start here
    if (h == l):
        return 0
    if (arr[l] == 0):
        return float('inf')
    min = float('inf')
    for i in range(l + 1, h + 1):
        if (i < l + arr[l] + 1):
            jumps = minJumps(arr, i, h)
            if (jumps != float('inf') and
                       jumps + 1 < min):
                min = jumps + 1
 
    return min
    #End here
arr = []
n = int(input()) 
for i in range(n):
    arr.append(float(input()))
print('Minimum number of jumps to reach','end is', minJumps(arr, 0, n-1))




You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell.
class Solution(object):
    def cherryPickup(self, grid):
        def dp(k):
            #########  Add your code here ##########
            #Start here
            if k == ROW_NUM - 1:
                return [[grid[-1][i] if i == j else grid[-1][i] + grid[-1][j] for j in range(COL_NUM)]
                        for i in range(COL_NUM)]
            row = grid[k]
            ans = [[0] * COL_NUM for i in range(COL_NUM)]
            next_dp = dp(k + 1)
            for i in range(COL_NUM):
                for j in range(i, COL_NUM):
                    for di in [-1, 0, 1]:
                        for dj in [-1, 0, 1]:
                            if 0 <= i + di < COL_NUM and 0 <= j + dj < COL_NUM:
                                if i == j:
                                    ans[i][j] = max(ans[i][j], next_dp[i + di][j + dj] + row[i])
                                else:
                                    ans[i][j] = max(ans[i][j], next_dp[i + di][j + dj] + row[i] + row[j])
            return ans
            #End here
        ROW_NUM = len(grid)
        COL_NUM = len(grid[0])
        return dp(0)[0][COL_NUM - 1]
        
grid=[[3,1,1],
      [2,5,1],
      [1,5,5],
      [2,1,1]]
ob=Solution()
print(ob.cherryPickup(grid))

##
You are given an n x n grid representing a field of cherries, each cell is one of three possible integers.
class Solution:
    def cherryPickup(self, grid):
        n = len(grid)
        #############    Add your code here  ############### 
        #Start here
        dp = [[-1] * (n + 1) for _ in range(n + 1)]
        dp[1][1] = grid[0][0]
        for m in range(1, (n << 1) - 1):
            for i in range(min(m, n - 1), max(-1, m - n), -1):
                for p in range(i, max(-1, m - n), -1):
                    j, q = m - i, m - p
                    if grid[i][j] == -1 or grid[p][q] == -1:
                        dp[i + 1][p + 1] = -1
                    else:
                        dp[i + 1][p + 1] = max(dp[i + 1][p + 1], dp[i][p + 1], dp[i + 1][p], dp[i][p])
                        if dp[i + 1][p + 1] != -1: dp[i + 1][p + 1] += grid[i][j] + (grid[p][q] if i != p else 0)
        return max(0, dp[-1][-1])
        n,m=len(grid),len(grid[0])
        dp = [[[-1 for i in range(m)] for j1 in range(n)] for j2 in range(n)]
        #End here
        return f(0,0,m-1,dp)
obj=Solution()
grid=[[0,1,-1],[1,0,-1],[1,1,1]]        
print(obj.cherryPickup(grid))

##
Create a python program for 0/1 knapsack problem using naive recursion method
def knapSack(W, wt, val, n):
    ############### Add your code here ##############
    #Start here
	if n == 0 or W == 0 :
		return 0
	if (wt[n-1] > W):
		return knapSack(W, wt, val, n-1)
	else:
		return max(val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), knapSack(W, wt, val, n-1))
	#End here
x=int(input())
y=int(input())
W=int(input())
val=[]
wt=[]
for i in range(x):
    val.append(int(input()))
for y in range(y):
    wt.append(int(input()))
n = len(val)
print('The maximum value that can be put in a knapsack of capacity W is: ',knapSack(W, wt, val, n))

##
Create a python program using dynamic programming for 0/1 knapsack problem.
def knapSack(W, wt, val, n):
    ########## Add your code here #########
    #Start here
	if n == 0 or W == 0 :
		return 0
	if (wt[n-1] > W):
		return knapSack(W, wt, val, n-1)
	else:
		return max(val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), knapSack(W, wt, val, n-1))
	#End here
x=int(input())
y=int(input())
W=int(input())
val=[]
wt=[]
for i in range(x):
    val.append(int(input()))
for y in range(y):
    wt.append(int(input()))

n = len(val)
print('The maximum value that can be put in a knapsack of capacity W is: ',knapSack(W, wt, val, n))

##
Solve Travelling Sales man Problem for the following graph
from sys import maxsize
from itertools import permutations
V = 4
 

def travellingSalesmanProblem(graph, s):
    #Start here
    vertex = []
    for i in range(V):
        if i != s:
            vertex.append(i)
    min_path = maxsize
    next_permutation=permutations(vertex)
    
    for i in next_permutation:
        current_pathweight = 0
        k = s
        for j in i:
            current_pathweight += graph[k][j]
            k = j
        current_pathweight += graph[k][s]
        min_path = min(min_path, current_pathweight)
        
    return min_path
    #End here
 

   
 
 

if __name__ == "__main__":
    
 
    graph = [[0, 10, 15, 20], [10, 0, 35, 25],
            [15, 35, 0, 30], [20, 25, 30, 0]]
    s = 0
    print(travellingSalesmanProblem(graph, s))

##
Given a 2D matrix tsp[][], where each row has the array of distances from that indexed city to all the other cities and -1 denotes that there doesn’t exist a path between those two indexed cities. The task is to print minimum cost in TSP cycle.
from typing import DefaultDict
 
 
INT_MAX = 2147483647
 

def findMinRoute(tsp):
    sum = 0
    counter = 0
    j = 0
    i = 0
    min = INT_MAX
    visitedRouteList = DefaultDict(int)
 
    
    visitedRouteList[0] = 1
    route = [0] * len(tsp)
 
    
    while i < len(tsp) and j < len(tsp[i]):
        #Start here
        if counter >= len(tsp[i]) - 1:
            break
        if j != i and (visitedRouteList[j] == 0):
            if tsp[i][j] < min:
                min = tsp[i][j]
                route[counter] = j + 1
        j += 1
        if j == len(tsp[i]):
            sum += min
            min = INT_MAX
            visitedRouteList[route[counter] - 1] = 1
            j = 0
            i = route[counter] - 1
            counter += 1
    i = route[counter - 1] - 1
    #End here
 

 
    for j in range(len(tsp)):
 
        if (i != j) and tsp[i][j] < min:
            min = tsp[i][j]
            route[counter] = j + 1
 
    sum += min
 
    
    print("Minimum Cost is :", sum)
 
 # Driver Code
if __name__ == "__main__":
 
  
    tsp = [[-1, 30, 25, 10], 
[15, -1, 20, 40], 
[10, 20, -1, 25], 
[30, 10, 20, -1]] 
 
    # Function Call
    findMinRoute(tsp)

##
Create a python program using brute force method of searching for the given substring in the main string.
import re #Import this package
def match(str1,str2):
    ########### Add your code here #######
    #Start here
    pattern = re.compile(str2)
    r = pattern.search(str1)
    while r:
        print("Found at index {}".format(r.start()))
        r = pattern.search(str1,r.start() + 1)
    #End here
str1=input()
str2=input()

##
Create a python program to find the maximum value in linear search.
def find_maximum(lst):
    #############  Add your code here ##############
    #Start here
    max=None
    for i in lst:
        if max == None or i > max:
            max = i
    return max
    #End here
test_scores = []
n=int(input())
for i in range(n):
    test_scores.append(int(input()))
print("Maximum value is ",find_maximum(test_scores))






