Given a positive integer num, return true if num is a perfect square or false otherwise.
import java.util.Scanner;
public class Solution 
{
    public boolean isPerfectSquare(int num) 
    {
      if(num<2)return true;
      long low=0,high=(long)num;
      while(low<=high)
      {
          long mid=(high+low)/2;
          long val=mid*mid;
          if(val==num)
          {
            return true;
          }
          else if(val>num)
          {
            high=mid-1;
          }
          else
          {
            low=mid+1;
          }
      }
      return false;
    }
}

##
You may recall that an array arr is a mountain array if and only if:
import java.util.Scanner;

class Solution {
    public int longestMountain(int[] arr) {
     int n=arr.length;
     int res=0;
     int up[]=new int[n];
     int down[]=new int[n];
     for(int i=n-2;i>=0;i--){
         if(arr[i]>arr[i+1]){
             down[i]=down[i+1]+1;
         }
     }
     for(int i=1;i<n;i++){
         if(arr[i]>arr[i-1]){
             up[i]=up[i-1]+1;
         }if(down[i]>0 && up[i]>0){
             res=Math.max(res,up[i]+down[i]+1);
         }
     }
     return res;
    }
}

##
Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.
import java.util.*;

class Solution {

    public int firstMissingPositive(int[] nums) {
     HashSet<Integer> hs=new HashSet<>();
     int max=Integer.MIN_VALUE;
     for(int i=0;i<nums.length;i++){
         if(nums[i]>0 && nums[i]>max){
             max=nums[i];
         }hs.add(nums[i]);
     }int i=1;
     for(i=1;i<=max;i++){
         if(!hs.contains(i)){
             break;
         }
     }return i;
    }
}

##
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
import java.util.*;

public class Solution {
    public boolean isValid(String s) {
        if(s.length()%2!=0) return false;
        Stack<Character> st=new Stack<>();
        for(char i:s.toCharArray()){
            if(i=='(' || i=='{' || i=='['){
                st.push(i);
            }else{
                if(i==')' && !st.isEmpty() && st.peek()=='('){
                    st.pop();
                }else if(i=='}' && !st.isEmpty() && st.peek()=='{'){
                    st.pop();
                }else if(i==']' && !st.isEmpty() && st.peek()=='['){
                    st.pop();
                }
            }
        }
        return st.isEmpty();
    }
}

##
Find First and Last Position of Element in Sorted Array
import java.util.*;

public class Solution 
{
    public int[] searchRange(int[] nums, int target) 
    {
        //Type Code Here............
        int low=0,high=nums.length-1;
        int[] res={-1,-1};
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(nums[mid]==target)
            {
                int i=mid;
                while(i>=0 && nums[i]==target)
                {
                    i--;
                }
                res[0]=i+1;
                int j=mid;
                while(j<nums.length && nums[j]==target)
                {
                    j++;
                }
                res[1]=j-1;
                return res;
            }
            else if(nums[mid]>target)
            {
                high=mid-1;
            }
            else
            {
                low=mid+1;
            }
        }
        return res;
    }
}

##
Largest Rectangle in Histogram
import java.util.*;

public class Solution 
{
    public int largestRectangleArea(int[] heights) 
    {
       //Type Code Here......
       int maxarea=0;
       Stack<int[]> st=new Stack<>();
       for(int i=0;i<heights.length;i++)
       {
           int start=i;
           while(!st.isEmpty() && heights[i]<st.peek()[1])
           {
               int[] top=st.pop();
               int ind=top[0];
               int ele=top[1];
               maxarea=Math.max(maxarea,ele*(i-ind));
               start=ind;
               
           }
           st.push(new int[]{start,heights[i]});
       }
       while(!st.isEmpty())
       {
           int[] top=st.pop();
           int ind=top[0];
           int ele=top[1];
           maxarea=Math.max(maxarea,ele*(heights.length-ind));
       }
       return maxarea;
    }
}

##
Kth Missing Positive Number
import java.util.Scanner;

class Solution 
{
    public int findKthPositive(int[] arr, int k) 
    {
       int low=0,high=arr.length;
       while(low<high){
           int mid=low+(high-low)/2;
           int miss=arr[mid]-(mid+1);
           if(miss<k)
           {
               low=mid+1;
           }
           else
           {
               high=mid;
           }
       }
       return low+k;       
    }
}

##
Minimum Remove to make valid parentheses
import java.util.Scanner;
import java.util.Stack;

class Solution 
{
    public String minRemoveToMakeValid(String s) 
    {
        Stack<Integer> stack=new Stack<>();
        StringBuilder st=new StringBuilder(s);
        int len=st.length();
        int i=0;
        while(i<len)
        {
            char ch=st.charAt(i);
            if(ch=='(')
            {
                stack.push(i);
            }
            else if(ch==')'){
                if(!stack.isEmpty())
                {
                    stack.pop();
                }
                else
                {
                    st.setCharAt(i,'*');
                }
            }
            i++;
        }
        while(!stack.isEmpty())
        {
            st.setCharAt(stack.pop(),'*');
        }
        StringBuilder result=new StringBuilder();
        for(int j=0;j<len;j++)
        {
            if(st.charAt(j)!='*')
            {
                result.append(st.charAt(j));
            }
            
        }
        return result.toString();
    }
}

##
Basic Calculator
import java.util.Scanner;
import java.util.Stack;

class Solution 
{
    public int calculate(String s) 
    {
      Stack<Integer> stack=new Stack<>();
      int result=0;
      int sign=1;
      int i=0;
      int length=s.length();
      while(i<length)
      {
          char ch=s.charAt(i);
          if(Character.isDigit(ch))
          {
              int num=0;
              while(i<length && Character.isDigit(s.charAt(i)))
              {
                  num=num*10+(s.charAt(i)-'0');
                  i++;
              }
              result+=sign*num;
              i--;
          }
          else if(ch=='+')sign=1;
          else if(ch=='-')sign=-1;
          else if(ch=='('){
              stack.push(result);
              stack.push(sign);
              sign=1;
              result=0;
          }
          else if(ch==')')
          {
              result*=stack.pop();
              result+=stack.pop();
          }
          i++;
      }
      return result;
    }
}

##
Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.
import java.util.*;

public class Solution 
{
    public int[] sortedSquares(int[] nums) 
    {
       int left=0;
       int right=nums.length -1;
       int[] result=new int[nums.length];
       for(int i=nums.length-1;i>=0;i--)
       {
           if(Math.abs(nums[left])>Math.abs(nums[right]))
           {
               result[i]=nums[left]*nums[left];
               left++;
           }
           else
           {
               result[i]=nums[right]*nums[right];
               right--;
           }
       }
       return result;
    }
}

##
Given a string s, find the length of the longest  substring
without repeating characters.
import java.util.*;

public class Solution 
{
    public int lengthOfLongestSubstring(String s) 
    {
        HashSet<Character> hs=new HashSet<>();
        int l=0;
        int maxlen=0;
        for(int r=0;r<s.length();r++){
            while(hs.contains(s.charAt(r)))
            {
                hs.remove(s.charAt(l));
                l++;
            }
            hs.add(s.charAt(r));
            maxlen=Math.max(maxlen,r-l+1);
        }
        return maxlen;
    }
}

##
You are given an array prices where prices[i] is the price of a given stock on the ith day.
import java.util.*;

public class Solution 
{
    public int maxProfit(int[] prices)
     {
        // Type Code Here......................
        int hold1=Integer.MIN_VALUE;
        int hold2=Integer.MIN_VALUE;
        int release1=0;
        int release2=0;
        for(int i:prices)
        {
            release2=Math.max(release2,hold2+i);
            hold2=Math.max(hold2,release1-i);
            release1=Math.max(release1,hold1+i);
            hold1=Math.max(hold1,-i);
        }
        return release2;
    }
}

##
Climbing Stairs
import java.util.*;

public class Solution
{
    public int climbStairs(int n)
    {
     if(n<=2){
         return n;
     }
     int w1=1;
     int w2=2;
     int wn=0;
     for(int i=3;i<=n;i++)
     {
         wn=w1+w2;
         w1=w2;
         w2=wn;
     }
     return wn;
    }
}

##
Given an integer array nums, find the  subarray with the largest sum, and return its sum.
import java.util.*;

public class Solution 
{
    public int maxSubArray(int[] nums)
    {
        int max=Integer.MIN_VALUE;
        int sum=0;
        for(int i=0;i<nums.length;i++)
        {
            sum=sum+nums[i];
            if(sum>max)
            {
                max=sum;
            }
            if(sum<0)
            {
                sum=0;
            }
        }
        return max;
    }
}

##
Max Points on a Line
import java.util.*;

public class Solution {
    public int maxPoints(int[][] points) {
        int n = points.length;
        if (n <= 2) {
            return n;
        }
        int ans = 2;
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int temp = 2;
                for (int k = j + 1; k < n; k++) {
                    int x = points[j][0] - points[k][0];
                    int y = points[k][1] - points[j][1];
                    if (Math.abs(x) == Math.abs(y)) {
                        temp++;
                    }
                }
                if (temp > ans) {
                    ans = temp;
                }
            }
        }
        return ans - 1;
    }
}

##
Plus One 
import java.util.*;

public class Solution
{
    public int[] plusOne(int[] digits)
    {
        for(int i=digits.length-1;i>=0;i--){
            if(digits[i]+1!=10){
                digits[i]+=1;
                return digits;
            }
            digits[i]=0;
        }
        int[] res=new int[digits.length+1];
        res[0]=1;
        return res;
    }
}

##
Given an integer n, return the number of prime numbers that are strictly less than n.
import java.util.ArrayList;
import java.util.*;
import java.util.Scanner;

public class Solution 
{
    public int countPrimes(int n) 
    {
        if(n<=2){
            return 0;
        }
        boolean[] isprime=new boolean[n];
        Arrays.fill(isprime,true);
        isprime[0]=false;
        isprime[1]=false;
        for(int i=2;i*i<n;i++)
        {
            if(isprime[i])
            {
                for(int j=i*i;j<n;j+=i)
                {
                    isprime[j]=false;
                }
            }
        }
        int c=0;
        for(boolean x:isprime)
        {
            if(x)
            {
            c++;
            }
        }
        return c; 
    }
}

##
Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:
import java.util.Scanner;
import java.util.regex.*;

public class Solution 
{
    public boolean isMatch(String s, String p) 
    {
        if(p.isEmpty())
        {
            return s.isEmpty();
        }
        boolean fm=((!s.isEmpty())&&(s.charAt(0)==p.charAt(0) || p.charAt(0)=='.'));
        if(p.length()>=2 && p.charAt(1)=='*')
        {
            return ((fm && isMatch(s.substring(1),p))|| isMatch(s,p.substring(2)));
        } 
        else
        {
            return (fm && isMatch(s.substring(1),p.substring(1)));
        }
    }
}

##
Divide Two Integers
import java.util.Scanner;

public class Solution {
    public int divide(int dividend, int divisor) {
    int result = dividend/divisor;
    return result;
    }
}

##
Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one.
import java.util.Arrays;
import java.util.Scanner;
import java.util.*;

public class Solution {
    int reverse(int n){
        int rem;
        int res =0;
        while(n>0){
            rem = n%10;
            res = (res*10) + rem;
            n/=10;
        }
        return res;
    }
    public String nearestPalindromic(String n) {
        int s = Integer.parseInt(n);
        int res=0, res1=0;
        int count=0, count1=0;
        for(int i=s+1;i<s*2;i++){
            if(reverse(i)==i){
                 res = i;
                 count = reverse(i)- s;
                break;
            }
        }
        
        for(int i=s-1;i>=0;i--){
            if(reverse(i)==i){
                res1 = i;
                count1 = s - reverse(i);
                break;
            }
        }
        if(count<count1){
            return Integer.toString(res);
        }
        
        return Integer.toString(res1);
    
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        //System.out.print("Enter a number: ");
        String input = scanner.nextLine();

        Solution solution = new Solution();
        String result = solution.nearestPalindromic(input);
        System.out.println(result);
        
        scanner.close();
    }
}






